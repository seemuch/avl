\begin{verbatim}
file: avl/configure.ac

AC_INIT([avl], [0.1], [avl-plt@googlegroups.com], [],
    [https://github.com/wqfish/avl])

AM_INIT_AUTOMAKE([-Wall -Werror foreign])

AC_PROG_CC
AC_PROG_CXX
AC_PROG_LEX
AC_PROG_YACC

AC_CONFIG_MACRO_DIR([m4])
AM_PROG_AR
AC_PROG_LIBTOOL

AC_CONFIG_HEADERS([config.h])
AC_CONFIG_FILES([
         Makefile
         src/Makefile
         lib/Makefile
         sample_code/Makefile
         tests/Makefile
         tests/libavl.test/Makefile
         tests/avl.test/Makefile
         tests/error.test/Makefile
         ])

AC_OUTPUT



file: avl/lib/AvlTypes.h

#ifndef AVL_TYPES_H_
#define AVL_TYPES_H_

#include <GL/freeglut.h>
#include <initializer_list>
#include <vector>
#include <string>
#include <memory>
#include <thread>
#include <mutex>
#include <iostream>
#include "AvlUtils.h"
#include "AvlVisualizer.h"

const float DEFAULT_DELAY = 0.5;

const int FPS = 20;

typedef unsigned int AvlColor;
const AvlColor AVL_RED = 0xFF0000;
const AvlColor AVL_GREEN = 0x00FF00;
const AvlColor AVL_WHIGHT = 0xFFFFFF;
const AvlColor AVL_COLOR_HIGHLIGHT = AVL_GREEN;
const AvlColor AVL_COLOR_DEFAULT = AVL_RED;
const AvlColor AVL_AUXILIARY_COLOR = AVL_WHIGHT;

class AvlFont
{
    public:
        // constructor
        AvlFont(void *font = GLUT_BITMAP_9_BY_15)
        {
            _font = font;
            if (font == GLUT_BITMAP_9_BY_15) {
                _width = 9;
                _height = 15;
            }
            else {
                _width = 0;
                _height = 0;
            }
        }

        // assignment operator 
        const AvlFont& operator=(void *font)
        {
            _font = font;
            if (font == GLUT_BITMAP_9_BY_15) {
                _width = 9;
                _height = 15;
            }
            else {
                _width = 0;
                _height = 0;
            }

            return *this;
        }
        
        // getter functions 
        GLfloat width() const { return _width; }
        GLfloat height() const { return _height; }
        void *font() const { return _font; }

    private:
        void *_font;
        GLfloat _width;
        GLfloat _height;
}; // end of AvlFont

class AvlObject
{
    public:
        // constructor
        AvlObject(GLfloat x = 0, GLfloat y = 0, const AvlFont &font = GLUT_BITMAP_9_BY_15)
        {
            _x = x;
            _y = y;
            _width = font.width();
            _height = font.height();
            _font = font;
            _color = AVL_COLOR_DEFAULT;

            _vi = NULL;
        }

        // copy constructor
        AvlObject(const AvlObject &obj)
        {
            _x = obj._x;
            _y = obj._y;
            _width = obj._width;
            _height = obj._height;
            _font = obj._font;
            _color = obj._color;

            _vi = obj._vi;
        }

        // assignment operator
        const AvlObject& operator=(const AvlObject &obj)
        {
            _x = obj._x;
            _y = obj._y;
            _width = obj._width;
            _height = obj._height;
            _font = obj._font;
            _color = obj._color;

            _vi = obj._vi;

            return *this;
        }

        // destructor (virtual)
        virtual ~AvlObject()
        {
            _vi->delObject(name());
        }

        // getter functions
        GLfloat x() const { return _x; }
        GLfloat y() const { return _y; }
        GLfloat width() const { return _width; }
        GLfloat height() const { return _height; }
        AvlFont font() const { return _font; }
        AvlColor color() const { return _color; }
        std::string name() const { return _name; }

        // setter functions
        void set_x(GLfloat x) { _x = x; }
        void set_y(GLfloat y) { _y = y; }
        void set_font(const AvlFont &font) { _font = font; }
        void set_color(AvlColor color) { _color = color; }
        void set_name(const std::string& name) { _name = name; }

        virtual void render() = 0;

        // locks
        void lock() { mtx.lock(); }
        bool try_lock() { return mtx.try_lock(); }
        void unlock() { mtx.unlock(); }

        // set visualizer
        void setVisualizer(AvlVisualizer *vi) { _vi = vi; }

    protected:
        // position setter
        void set_width(GLfloat width) { _width = width; }
        void set_height(GLfloat height) { _height = height; }

        bool isDisplaying() const { return _vi->getLevel() > 0; }

    private:
        GLfloat _x;
        GLfloat _y;
        GLfloat _width;
        GLfloat _height;
        AvlFont _font;
        AvlColor _color;

        std::mutex mtx;

        AvlVisualizer *_vi;

        std::string _name;
}; // end of AvlObject

inline void moveObject(std::shared_ptr<AvlObject> obj, GLfloat x, GLfloat y, float seconds)
{
    int steps = FPS * seconds;
    GLfloat delta_x = x / steps;
    GLfloat delta_y = y / steps;

    for (int i = 0; i < steps; i++) {
        obj->lock();
        obj->set_x(obj->x() + delta_x);
        obj->set_y(obj->y() + delta_y);
        obj->unlock();
        avlSleep(1.0 / FPS);
    }
}

class AvlInt : public AvlObject
{
    public:
        // constructor
        AvlInt(int v = 0, GLfloat x = 0, GLfloat y = 0, void *font = GLUT_BITMAP_9_BY_15)
            : AvlObject(x, y, font)
        {
            value = v;
            update();
        }

        // destructor
        virtual ~AvlInt() {}

        // assignment operator
        const AvlInt& operator=(int v) { value = v; update(); return *this; }

        // << operator
        friend std::ostream& operator<<(std::ostream &os, const AvlInt &v)
        {
            os << v.value;
            return os;
        }

        // unary plus and minus
        const AvlInt& operator+() const { return *this; }
        const AvlInt operator-() const
        {
            AvlInt ret = *this;
            ret.value = -value;
            ret.update();
            return ret;
        }

        // pre-increment and post-increment
        const AvlInt& operator++() { value++; update(); return *this; }
        const AvlInt operator++(int)
        {
            AvlInt ret = *this;
            value++;
            update();
            return ret;
        }

        // pre-decrement and post-decrement
        const AvlInt& operator--() { value--; update(); return *this; }
        const AvlInt operator--(int)
        {
            AvlInt ret = *this;
            value--;
            update();
            return ret;
        }

        // binary plus
        const AvlInt operator+(int v) const
        {
            AvlInt ret = *this;
            ret.value += v;
            ret.update();
            return ret;
        }

        // binary plus
        const AvlInt operator+(const AvlInt &v) const { return *this + v.value; }
        friend const AvlInt operator+(int v1, const AvlInt &v2) { return v2 + v1; }

        // compound plus 
        const AvlInt& operator+=(int v) { value += v; update(); return *this; }
        const AvlInt& operator+=(const AvlInt &v) { return *this += v.value; }
        
        
        // binary minus
        const AvlInt operator-(int v) const
        {
            AvlInt ret = *this;
            ret.value -= v;
            ret.update();
            return ret;
        }
        const AvlInt operator-(const AvlInt &v) const { return *this - v.value; }
        friend const AvlInt operator-(int v1, const AvlInt &v2) { return -v2 + v1; }

        // compound minus
        const AvlInt& operator-=(int v) { value -= v; update(); return *this; }
        const AvlInt& operator-=(const AvlInt &v) { return *this -= v.value; }


        // multiplication
        const AvlInt operator*(int v) const
        {
            AvlInt ret = *this;
            ret.value *= v;
            ret.update();
            return ret;
        }
        const AvlInt operator*(const AvlInt &v) const { return *this * v.value; }
        friend const AvlInt operator*(int v1, const AvlInt &v2) { return v2 * v1; }
        
        // compound multiplication
        const AvlInt& operator*=(int v) { value *= v; update(); return *this; }
        const AvlInt& operator*=(const AvlInt &v) { return *this *= v.value; }

        // devision
        const AvlInt operator/(int v) const
        {
            AvlInt ret = *this;
            ret.value /= v;
            ret.update();
            return ret;
        }
        const AvlInt operator/(const AvlInt &v) const { return *this / v.value; }
        friend const AvlInt operator/(int v1, const AvlInt &v2)
        {
            AvlInt ret = v2;
            ret.value = v1 / v2.value;
            ret.update();
            return ret;
        }

        // compound division
        const AvlInt& operator/=(int v) { value /= v; update(); return *this; }
        const AvlInt& operator/=(const AvlInt &v) { return *this /= v.value; }
    
        // binary mod
        const AvlInt operator%(int v) const
        {

            AvlInt ret = *this;
            ret.value %= v;
            ret.update();
            return ret;
        }
        const AvlInt operator%(const AvlInt &v) const { return *this % v.value; }
        friend const AvlInt operator%(int v1, const AvlInt &v2) 
        { 
            AvlInt ret = v2;
            ret.value = v1 % v2.value;
            ret.update();
            return ret;
        }

        // comparison operators
        bool operator <(int v) const { return value < v; }
        bool operator <(const AvlInt &v) const { return value < v.value; }
        friend bool operator<(int v1, const AvlInt v2) { return v1 < v2.value; }

        bool operator <=(int v) const { return value <= v; }
        bool operator <=(const AvlInt &v) const { return value <= v.value; }
        friend bool operator<=(int v1, const AvlInt v2) { return v1 <= v2.value; }

        bool operator >(int v) const { return value > v; }
        bool operator >(const AvlInt &v) const { return value > v.value; }
        friend bool operator>(int v1, const AvlInt v2) { return v1 > v2.value; }

        bool operator >=(int v) const { return value >= v; }
        bool operator >=(const AvlInt &v) const { return value >= v.value; }
        friend bool operator>=(int v1, const AvlInt v2) { return v1 >= v2.value; }

        bool operator ==(int v) const { return value == v; }
        bool operator ==(const AvlInt &v) const { return value == v.value; }
        friend bool operator==(int v1, const AvlInt v2) { return v1 == v2.value; }

        bool operator !=(int v) const { return value != v; }
        bool operator !=(const AvlInt &v) const { return value != v.value; }
        friend bool operator!=(int v1, const AvlInt v2) { return v1 != v2.value; }

        // value getter
        int val() const { return value; }

        // render function
        virtual void render()
        {
            unsigned int red = color() / 0x10000;
            unsigned int green = color() % 0x10000 / 0x100;
            unsigned int blue = color() % 0x100;
            glColor4f(red / 255.0, green / 255.0, blue / 255.0, 0.0);

            glRasterPos2f(x(), y());
            glutBitmapString(font().font(), (const unsigned char *)(std::to_string(value).c_str()));
        }

        void highlight() { 
            set_color(AVL_COLOR_HIGHLIGHT); 
        }
        void lowlight() { 
            set_color(AVL_COLOR_DEFAULT); 
        }

        const AvlInt& assign(const AvlInt& v)
        {
            if (!isDisplaying()) {
                *this = v;
                return *this;
            }

            avlSleep(DEFAULT_DELAY);
            *this = v;
            avlSleep(DEFAULT_DELAY);

            return *this;
        }

    private:
        void update() { set_width(numOfDigit() * font().width()); }

        int numOfDigit() const
        {
            if (value == 0)
                return 1;

            int num = value >= 0 ? 0 : 1;
            int k = value;

            while (k != 0) {
                k /= 10;
                num++;
            }

            return num;
        }

        int value;
}; // end of AvlInt

class AvlChar: public AvlObject
{
    public:
        // constructor
        AvlChar (char v = 0, GLfloat x = 0, GLfloat y = 0, void *font = GLUT_BITMAP_9_BY_15)
            : AvlObject(x, y, font)
        {
            value = v;
        }

        // destructor
        virtual ~AvlChar() {}

        // assignment operator
        const AvlChar & operator=(char v) { value = v; return *this; }

        // << operator
        friend std::ostream& operator<<(std::ostream &os, const AvlChar &v)
        {
            os << v.value;
            return os;
        }

        // unary plus and minus
        const AvlChar & operator+() const { return *this; }
        const AvlChar operator-() const
        {
            AvlChar ret = *this;
            ret.value = -value;
            return ret;
        }

        // pre-increment and post-increment
        const AvlChar & operator++() { value++; return *this; }
        const AvlChar operator++(int)
        {
            AvlChar ret = *this;
            value++;
            return ret;
        }

        // pre-decrement and post-decrement
        const AvlChar & operator--() { value--; return *this; }
        const AvlChar operator--(int)
        {
            AvlChar ret = *this;
            value--;
            return ret;
        }

        // binary plus
        const AvlChar operator+(int v) const
        {
            AvlChar ret = *this;
            ret.value += v;
            return ret;
        }

        const AvlChar operator+(char v) const
        {
            AvlChar ret = *this;
            ret.value += v;
            return ret;
        }

        // binary plus
        const AvlChar operator+(const AvlInt &v) const { return *this + v.val(); }
        const AvlChar operator+(const AvlChar &v) const { return *this +  v.val(); }
        friend const AvlChar operator+(int v1, const AvlChar &v2) { return v2 + v1; }
        friend const AvlChar operator+(char v1, const AvlChar &v2) { return v2 + v1; }
        friend const AvlChar operator+(AvlInt v1, const AvlChar &v2) { return v2 + v1.val(); }
        friend const AvlChar operator+(AvlChar v1, const AvlChar &v2) { return v2 + v1.val(); }

        // compound plus 
        const AvlChar & operator+=(int v) { value += v; return *this; }
        const AvlChar & operator+=(char v) { value += v; return *this; }
        const AvlChar & operator+=(const AvlInt &v) { return *this += v.val(); }
        const AvlChar & operator+=(const AvlChar &v) { return *this += v.val(); }

        
        // binary minus
        const AvlChar operator-(int v) const
        {
            AvlChar ret = *this;
            ret.value -= v;
            return ret;
        }

        const AvlChar operator-(char v) const
        {
            AvlChar ret = *this;
            ret.value -= v;
            return ret;
        }

        const AvlChar operator-(const AvlInt &v) const { return *this - v.val(); }
        const AvlChar operator-(const AvlChar &v) const { return *this - v.val(); }
        friend const AvlChar operator-(int v1, const AvlChar &v2) { return -v2 + v1; }
        friend const AvlChar operator-(char v1, const AvlChar &v2) { return -v2 + v1; }
        friend const AvlChar operator-(AvlInt v1, const AvlChar &v2) { return -v2 + v1.val(); }
        friend const AvlChar operator-(AvlChar v1, const AvlChar &v2) { return -v2 + v1.val(); }

        // compound minus
        const AvlChar & operator-=(int v) { value -= v; return *this; }
        const AvlChar & operator-=(char v) { value -= v; return *this; }
        const AvlChar & operator-=(const AvlInt &v) { return *this -= v.val(); }
        const AvlChar & operator-=(const AvlChar &v) { return *this -= v.val(); }


        // multiplication
        const AvlChar operator*(int v) const
        {
            AvlChar ret = *this;
            ret.value *= v;
            return ret;
        }

        const AvlChar operator*(char v) const
        {
            AvlChar ret = *this;
            ret.value *= v;
            return ret;
        }

        const AvlChar operator*(const AvlInt &v) const { return *this * v.val(); }
        const AvlChar operator*(const AvlChar &v) const { return *this * v.val(); }
        friend const AvlChar operator*(int v1, const AvlChar &v2) { return v2 * v1; }
        friend const AvlChar operator*(char v1, const AvlChar &v2) { return v2 * v1; }
        friend const AvlChar operator*(AvlInt v1, const AvlChar &v2) { return v2 * v1.val(); }
        friend const AvlChar operator*(AvlChar v1, const AvlChar &v2) { return v2 * v1.val(); }
        
        // compound multiplication
        const AvlChar & operator*=(int v) { value *= v; return *this; }
        const AvlChar & operator*=(char v) { value *= v; return *this; }
        const AvlChar & operator*=(const AvlInt &v) { return *this *= v.val(); }
        const AvlChar & operator*=(const AvlChar &v) { return *this *= v.val(); }

        // division
        const AvlChar operator/(int v) const
        {
            AvlChar ret = *this;
            ret.value /= v;
            return ret;
        }

        const AvlChar operator/(char v) const
        {
            AvlChar ret = *this;
            ret.value /= v;
            return ret;
        }

        const AvlChar operator/(const AvlInt &v) const { return *this / v.val(); }
        const AvlChar operator/(const AvlChar &v) const { return *this / v.val(); }
        friend const AvlChar operator/(int v1, const AvlChar &v2) { return v2 / v1; }
        friend const AvlChar operator/(char v1, const AvlChar &v2) { return v2 / v1; }
        friend const AvlChar operator/(AvlInt v1, const AvlChar &v2) { return v2 / v1.val(); }
        friend const AvlChar operator/(AvlChar v1, const AvlChar &v2) { return v2 / v1.val(); }

        // compound division
        const AvlChar & operator/=(int v) { value /= v; return *this; }
        const AvlChar & operator/=(char v) { value /= v; return *this; }
        const AvlChar & operator/=(const AvlInt &v) { return *this /= v.val(); }
        const AvlChar & operator/=(const AvlChar &v) { return *this /= v.val(); }
    
        // comparison operators
        bool operator <(int v) const { return value < v; }
        bool operator <(char v) const { return value < v; }
        bool operator <(const AvlInt &v) const { return value < v.val(); }
        bool operator <(const AvlChar &v) const { return value < v.value; }
        friend bool operator<(int v1, const AvlChar v2) { return v1 < v2.value; }
        friend bool operator<(AvlInt v1, const AvlChar v2) { return v1.val() < v2.value; }

        bool operator <=(int v) const { return value <= v; }
        bool operator <=(char v) const { return value <= v; }
        bool operator <=(const AvlInt &v) const { return value <= v.val(); }
        bool operator <=(const AvlChar &v) const { return value <= v.val(); }
        friend bool operator<=(int v1, const AvlChar v2) { return v1 <= v2.value; }
        friend bool operator<=(AvlInt v1, const AvlChar v2) { return v1.val() <= v2.value; }

        bool operator >(int v) const { return value > v; }
        bool operator >(char v) const { return value > v; }
        bool operator >(const AvlInt &v) const { return value > v.val(); }
        bool operator >(const AvlChar &v) const { return value > v.value; }
        friend bool operator>(int v1, const AvlChar v2) { return v1 > v2.value; }
        friend bool operator>(AvlInt v1, const AvlChar v2) { return v1.val() > v2.value; }

        bool operator >=(int v) const { return value >= v; }
        bool operator >=(char v) const { return value >= v; }
        bool operator >=(const AvlInt &v) const { return value >= v.val(); }
        bool operator >=(const AvlChar &v) const { return value >= v.value; }
        friend bool operator>=(int v1, const AvlChar v2) { return v1 >= v2.value; }
        friend bool operator>=(AvlInt v1, const AvlChar v2) { return v1.val() >= v2.value; }

        bool operator ==(int v) const { return value == v; }
        bool operator ==(char v) const { return value == v; }
        bool operator ==(const AvlChar &v) const { return value == v.value; }
        bool operator ==(const AvlInt &v) const { return value == v.val(); }
        friend bool operator==(char v1, const AvlChar v2) { return v1 == v2.value; }
        friend bool operator==(AvlInt v1, const AvlChar v2) { return v1.val() == v2.value; }

        bool operator !=(int v) const { return value != v; }
        bool operator !=(char v) const { return value != v; }
        bool operator !=(const AvlInt &v) const { return value != v.val(); }
        bool operator !=(const AvlChar &v) const { return value != v.value; }
        friend bool operator!=(int v1, const AvlChar v2) { return v1 != v2.value; }
        friend bool operator!=(AvlInt v1, const AvlChar v2) { return v1.val() != v2.value; }


        // value getter
        char val() const { return value; }

        // render function
        virtual void render()
        {
            unsigned int red = color() / 0x10000;
            unsigned int green = color() % 0x10000 / 0x100;
            unsigned int blue = color() % 0x100;
            glColor4f(red / 255.0, green / 255.0, blue / 255.0, 0.0);

            glRasterPos2f(x(), y());
            glutBitmapString(font().font(), (const unsigned char *)std::string(1, value).c_str());
        }

        void highlight() { 
            set_color(AVL_COLOR_HIGHLIGHT); 
        }
        void lowlight() { 
            set_color(AVL_COLOR_DEFAULT); 
        }

    private:
        char value;
}; // end of AvlChar

class array_entry {
public:
    AvlObject* obj;
    GLfloat x;
    GLfloat y;
};

class AvlIndex : public AvlObject {
public:
    // constructor 
    AvlIndex (int v = 0, GLfloat x = 0, GLfloat y = 0, void *font = GLUT_BITMAP_9_BY_15) : AvlObject(x, y, font) {
        this->value = v;
    }

    // constructor 
    AvlIndex (const AvlInt &v, GLfloat x = 0, GLfloat y = 0, void *font = GLUT_BITMAP_9_BY_15) : AvlObject(x, y, font) {
        this->value = v.val();
    }
    
    // << operator
    friend std::ostream& operator<<(std::ostream &os, const AvlIndex &v)
    {
        os << v.value;
        return os;
    }
    
    // assignment operator
    const AvlIndex& operator= (const AvlIndex& that) {
        this->value = that.value;
        return *this;
    }

    // assignment operator for integer type
    const AvlIndex& operator= (int a) {
        this->value = a;
        return *this;
    }

    // assignment operator for AvlInt type
    const AvlIndex& operator= (const AvlInt &a) {
        this->value = a.val();
        return *this;
    }

    // unary plus and minus
    const AvlIndex& operator+() const { return *this; }
    const AvlIndex operator-() const
    {
        AvlIndex ret = *this;
        ret.value = -value;
        ret.update();
        return ret;
    }

    // pre-increment and post-increment
    const AvlIndex& operator++() { value++; update(); return *this; }
    const AvlIndex operator++(int)
    {
        AvlIndex ret = *this;
        value++;
        update();
        return ret;
    }

    // pre-decrement and post-decrement
    const AvlIndex& operator--() { value--; update(); return *this; }
    const AvlIndex operator--(int)
    {
        AvlIndex ret = *this;
        value--;
        update();
        return ret;
    }

    // binary plus
    const AvlIndex operator+(size_t v) const
    {
        AvlIndex ret = *this;
        ret.value += v;
        ret.update();
        return ret;
    }

    const AvlIndex operator+(int v) const
    {
        AvlIndex ret = *this;
        ret.value += v;
        ret.update();
        return ret;
    }
    const AvlIndex operator+(char v) const
    {
        AvlIndex ret = *this;
        ret.value += (int) v;
        ret.update();
        return ret;
    }

    // binary plus
    const AvlIndex operator+(const AvlInt &v) const { return *this + v.val(); }
    const AvlIndex operator+(const AvlChar &v) const { return *this + v.val(); }
    const AvlIndex operator+(const AvlIndex &v) const { return *this + v.value; }
    friend const AvlIndex operator+(int v1, const AvlIndex &v2) { return v2 + v1; }
    friend const AvlIndex operator+(char v1, const AvlIndex &v2) { return v2 + v1; }
    friend const AvlIndex operator+(AvlInt v1, const AvlIndex &v2) { return v2 + v1.val(); }
    friend const AvlIndex operator+(AvlChar v1, const AvlIndex &v2) { return v2 + v1.val(); }

    // compound plus 
    const AvlIndex& operator+=(int v) { value += v; update(); return *this; }
    const AvlIndex& operator+=(size_t v) { value += v; update(); return *this; }
    const AvlIndex& operator+=(char v) { value += v; update(); return *this; }
    const AvlIndex& operator+=(const AvlInt &v) { return *this += v.val(); }
    const AvlIndex& operator+=(const AvlChar &v) { return *this += v.val(); }
    const AvlIndex& operator+=(const AvlIndex &v) { return *this += v.value; }
    
    // binary minus
    const AvlIndex operator-(int v) const
    {
        AvlIndex ret = *this;
        ret.value -= v;
        ret.update();
        return ret;
    }

    const AvlIndex operator-(size_t v) const
    {
        AvlIndex ret = *this;
        ret.value -= v;
        ret.update();
        return ret;
    }
    const AvlIndex operator-(char v) const
    {
        AvlIndex ret = *this;
        ret.value -= v;
        ret.update();
        return ret;
    }

    const AvlIndex operator-(const AvlInt &v) const { return *this - v.val(); }
    const AvlIndex operator-(const AvlChar &v) const { return *this - v.val(); }
    const AvlIndex operator-(const AvlIndex &v) const { return *this - v.value; }
    friend const AvlIndex operator-(int v1, const AvlIndex &v2) { return -v2 + v1; }
    friend const AvlIndex operator-(char v1, const AvlIndex &v2) { return -v2 + v1; }
    friend const AvlIndex operator-(AvlInt v1, const AvlIndex &v2) { return -v2 + v1.val(); }
    friend const AvlIndex operator-(AvlChar v1, const AvlIndex &v2) { return -v2 + v1.val(); }

    // compound minus
    const AvlIndex& operator-=(int v) { value -= v; update(); return *this; }
    const AvlIndex& operator-=(char v) { value -= v; update(); return *this; }
    const AvlIndex& operator-=(const AvlInt &v) { return *this -= v.val(); }
    const AvlIndex& operator-=(const AvlIndex &v) { return *this -= v.value; }
    const AvlIndex& operator-=(const AvlChar &v) { return *this -= v.val(); }

    // multiplication
    const AvlIndex operator*(int v) const
    {
        AvlIndex ret = *this;
        ret.value *= v;
        ret.update();
        return ret;
    }
    
    const AvlIndex operator*(char v) const
    {
        AvlIndex ret = *this;
        ret.value *= v;
        ret.update();
        return ret;
    }
    
    const AvlIndex operator*(const AvlInt &v) const { return *this * v.val(); }
    const AvlIndex operator*(const AvlChar &v) const { return *this * v.val(); }
    const AvlIndex operator*(const AvlIndex &v) const { return *this * v.value; }
    friend const AvlIndex operator*(int v1, const AvlIndex &v2) { return v2 * v1; }
    friend const AvlIndex operator*(char v1, const AvlIndex &v2) { return v2 * v1; }
    friend const AvlIndex operator*(AvlInt v1, const AvlIndex &v2) { return v2 * v1.val(); }
    friend const AvlIndex operator*(AvlChar v1, const AvlIndex &v2) { return v2 * v1.val(); }

    
    // compound multiplication
    const AvlIndex& operator*=(int v) { value *= v; update(); return *this; }
    const AvlIndex& operator*=(char v) { value *= v; update(); return *this; }
    const AvlIndex& operator*=(const AvlInt &v) { return *this *= v.val(); }
    const AvlIndex& operator*=(const AvlChar &v) { return *this *= v.val(); }
    const AvlIndex& operator*=(const AvlIndex &v) { return *this *= v.value; }

    // devision
    const AvlIndex operator/(int v) const
    {
        AvlIndex ret = *this;
        ret.value /= v;
        ret.update();
        return ret;
    }

    const AvlIndex operator/(char v) const
    {
        AvlIndex ret = *this;
        ret.value /= v;
        ret.update();
        return ret;
    }

    const AvlIndex operator/(const AvlInt &v) const { return *this / v.val(); }
    const AvlIndex operator/(const AvlChar &v) const { return *this / v.val(); }
    const AvlIndex operator/(const AvlIndex &v) const { return *this / v.value; }
    friend const AvlIndex operator/(int v1, const AvlIndex &v2) { return v2 / v1; }
    friend const AvlIndex operator/(char v1, const AvlIndex &v2) { return v2 / v1; }
    friend const AvlIndex operator/(AvlInt v1, const AvlIndex &v2) { return v2 / v1.val(); }
    friend const AvlIndex operator/(AvlChar v1, const AvlIndex &v2) { return v2 / v1.val(); }

    // compound division
    const AvlIndex & operator/=(int v) { value /= v; update(); return *this; }
    const AvlIndex & operator/=(char v) { value /= v; update(); return *this; }
    const AvlIndex & operator/=(const AvlInt &v) { return *this /= v.val(); }
    const AvlIndex & operator/=(const AvlChar &v) { return *this /= v.val(); }
    const AvlIndex & operator/=(const AvlIndex &v) { return *this /= v.value; }

    // comparison operators
    bool operator <(int v) const { return value < v; }
    bool operator <(size_t v) const { return (size_t)value < v; }
    bool operator <(char v) const { return value < v; }
    bool operator <(const AvlInt &v) const { return value < v.val(); }
    bool operator <(const AvlChar &v) const { return value < v.val(); }
    bool operator <(const AvlIndex &v) const { return value < v.val(); }
    friend bool operator<(int v1, const AvlIndex v2) { return v1 < v2.value; }
    friend bool operator<(char v1, const AvlIndex v2) { return v1 < v2.value; }
    friend bool operator<(AvlInt v1, const AvlIndex v2) { return v1.val() < v2.value; }
    friend bool operator<(AvlChar v1, const AvlIndex v2) { return v1.val() < v2.value; }

    bool operator <=(int v) const { return value <= v; }
    bool operator <=(char v) const { return value <= v; }
    bool operator <=(size_t v) const { return (size_t)value <= v; }
    bool operator <=(const AvlInt &v) const { return value <= v.val(); }
    bool operator <=(const AvlChar &v) const { return value <= v.val(); }
    bool operator <=(const AvlIndex &v) const { return value <= v.value; }
    friend bool operator<=(int v1, const AvlIndex v2) { return v1 <= v2.value; }
    friend bool operator<=(char v1, const AvlIndex v2) { return v1 <= v2.value; }
    friend bool operator<=(AvlInt v1, const AvlIndex v2) { return v1.val() <= v2.value; }
    friend bool operator<=(AvlChar v1, const AvlIndex v2) { return v1.val() <= v2.value; }

    bool operator >(int v) const { return value > v; }
    bool operator >(char v) const { return value > v; }
    bool operator >(size_t v) const { return (size_t)value > v; }
    bool operator >(const AvlInt &v) const { return value > v.val(); }
    bool operator >(const AvlChar &v) const { return value > v.val(); }
    bool operator >(const AvlIndex &v) const { return value > v.value; }
    friend bool operator>(int v1, const AvlIndex v2) { return v1 > v2.value; }
    friend bool operator>(char v1, const AvlIndex v2) { return v1 > v2.value; }
    friend bool operator>(AvlInt v1, const AvlIndex v2) { return v1.val() > v2.value; }
    friend bool operator>(AvlChar v1, const AvlIndex v2) { return v1.val() > v2.value; }

    bool operator >=(int v) const { return value >= v; }
    bool operator >=(char v) const { return value >= v; }
    bool operator >=(size_t v) const { return (size_t)value >= v; }
    bool operator >=(const AvlInt &v) const { return value >= v.val(); }
    bool operator >=(const AvlChar &v) const { return value >= v.val(); }
    bool operator >=(const AvlIndex &v) const { return value >= v.value; }
    friend bool operator>=(int v1, const AvlIndex v2) { return v1 >= v2.value; }
    friend bool operator>=(char v1, const AvlIndex v2) { return v1 >= v2.value; }
    friend bool operator>=(AvlInt v1, const AvlIndex v2) { return v1.val() >= v2.value; }
    friend bool operator>=(AvlChar v1, const AvlIndex v2) { return v1.val() >= v2.value; }

    bool operator ==(int v) const { return value == v; }
    bool operator ==(char v) const { return value == v; }
    bool operator ==(size_t v) const { return (size_t)value == v; }
    bool operator ==(const AvlInt &v) const { return value == v.val(); }
    bool operator ==(const AvlChar &v) const { return value == v.val(); }
    bool operator ==(const AvlIndex &v) const { return value == v.value; }
    friend bool operator==(int v1, const AvlIndex v2) { return v1 == v2.value; }
    friend bool operator==(char v1, const AvlIndex v2) { return v1 == v2.value; }
    friend bool operator==(AvlInt v1, const AvlIndex v2) { return v1.val() == v2.value; }
    friend bool operator==(AvlChar v1, const AvlIndex v2) { return v1.val() == v2.value; }

    bool operator !=(int v) const { return value != v; }
    bool operator !=(char v) const { return value != v; }
    bool operator !=(size_t v) const { return (size_t)value != v; }
    bool operator !=(const AvlInt &v) const { return value != v.val(); }
    bool operator !=(const AvlChar &v) const { return value != v.val(); }
    bool operator !=(const AvlIndex &v) const { return value != v.value; }
    friend bool operator!=(int v1, const AvlIndex v2) { return v1 != v2.value; }
    friend bool operator!=(char v1, const AvlIndex v2) { return v1 != v2.value; }
    friend bool operator!=(AvlInt v1, const AvlIndex v2) { return v1.val() != v2.value; }
    friend bool operator!=(AvlChar v1, const AvlIndex v2) { return v1.val() != v2.value; }

    // value getter
    int val() const { return value; }

    // render function
    virtual void render()
    {
        unsigned int red = color() / 0x10000;
        unsigned int green = color() % 0x10000 / 0x100;
        unsigned int blue = color() % 0x100;
        glColor4f(red / 255.0, green / 255.0, blue / 255.0, 0.0);

        for (std::vector<array_entry>::iterator itr = array_set.begin(); itr != array_set.end(); itr ++) {
            glRasterPos2f(itr->x, itr->y);
            glutBitmapString(AvlFont().font(), (const unsigned char *)(name().c_str()));

        }
    }

    void highlight() { 
        set_color(AVL_COLOR_HIGHLIGHT); 
    }
    void lowlight() { 
        set_color(AVL_COLOR_DEFAULT); 
    }

    void add_array(AvlObject* obj, GLfloat a, GLfloat b) {
        for (size_t i = 0; i < array_set.size(); i ++) {
            if (array_set[i].x == a && array_set[i].y == b)
                return;
            if (obj == array_set[i].obj)
                return;
        }
        array_entry ae;
        ae.obj = obj;
        ae.x = a;
        ae.y = b;
        array_set.push_back(ae);
    }

private:
    int value;
    std::vector<array_entry> array_set;
    void update() { set_width(name().size() * font().width()); }


}; // end of AvlIndex



class AvlString: public AvlObject
{
    public:
        // constructor
        AvlString (const char *v, GLfloat x = 0, GLfloat y = 0, void *font = GLUT_BITMAP_9_BY_15)
            : AvlObject(x, y, font)
        {
            value = v;
            update();
        }

        AvlString (char v, GLfloat x = 0, GLfloat y = 0, void *font = GLUT_BITMAP_9_BY_15)
            : AvlObject(x, y, font)
        {
            value = v;
            update();
        }
    

        // destructor
        virtual ~AvlString() {}

        // assignment operator
        const AvlString & operator=(const char *v) { value = v; update(); return *this; }
        const AvlString & operator=(char v) { value = v; update(); return *this; }

        // << operator
        friend std::ostream& operator<<(std::ostream &os, const AvlString &v)
        {
            os << v.value;
            return os;
        }



        // binary plus
        const AvlString operator+(const char *v) const
        {
            AvlString ret = *this;
            ret.value += v;
            ret.update();
            return ret;
        }
    
        const AvlString operator+(char v) const
        {
            AvlString ret = *this;
            ret.value += v;
            ret.update();
            return ret;
        }

        // binary plus
        const AvlString operator+(const AvlChar &v) const { return *this +  v.val(); }
        const AvlString operator+(const AvlString &v) const 
        { 
            AvlString ret = *this;
            ret.value += v.val();
            ret.update();
            return ret;
        }
        friend const AvlString operator+( char v1, const AvlString &v2 )
        {
            AvlString ret = v1;
            ret.value += v2.val();
            ret.update();
            return ret;
        }
        friend const AvlString operator+(const char *v1, const AvlString &v2)
        {
            AvlString ret = v1;
            ret.value += v2.val();
            ret.update();
            return ret;
        }
        friend const AvlString operator+(AvlChar v1, const AvlString &v2) { return v1.val() + v2; }

        // compound plus 
        const AvlString & operator+=(char v) { value += v; update(); return *this; }
        const AvlString & operator+=(const AvlChar &v) { return *this += v.val(); }
        const AvlString & operator+=(const char *v) { value += v; update(); return *this; }
        const AvlString & operator+=(const AvlString &v) { value += v.val(); update(); return *this; }



        // value getter
        std::string val() const { return value; }

        // render function
        virtual void render()
        {
            unsigned int red = color() / 0x10000;
            unsigned int green = color() % 0x10000 / 0x100;
            unsigned int blue = color() % 0x100;
            glColor4f(red / 255.0, green / 255.0, blue / 255.0, 0.0);

            glRasterPos2f(x(), y());
            glutBitmapString(font().font(), reinterpret_cast<const unsigned char *> (value.c_str()) );
        }

        void highlight() { 
            set_color(AVL_COLOR_HIGHLIGHT); 
        }
        void lowlight() { 
            set_color(AVL_COLOR_DEFAULT); 
        }

    private:
        void update() { set_width(value.size()*font().width()); }
        std::string value;
}; // end of AvlString


// ***NOTE!***: every element in this array is a pointer
template <typename T>
class AvlArray : public AvlObject
{
    public:
        // default constructor
        AvlArray(size_t size = 0, GLfloat x = 0, GLfloat y = 0,
                const AvlFont &font = GLUT_BITMAP_9_BY_15) : AvlObject(x, y, font), arr(size), index_x(size), index_y(size)
        {
            for (size_t i = 0; i < arr.size(); i ++) {
                arr[i] = std::shared_ptr<T>(new T);
            }

            updateMutex = std::shared_ptr<std::mutex>(new std::mutex);
            toplevelArray = this;

            update();
        }

        // constructor with initializer list
        AvlArray(const std::initializer_list<T> &l) : arr(l.size()), index_x(l.size()), index_y(l.size())
        {
            typename std::initializer_list<T>::const_iterator src = l.begin();
            typename std::vector< std::shared_ptr<T> >::iterator dst = arr.begin();

            while (src != l.end()) {
                *dst = std::shared_ptr<T>(new T(*src));
                src++;
                dst++;
            }

            updateMutex = std::shared_ptr<std::mutex>(new std::mutex);
            toplevelArray = this;

            update();
        }

        // destructor
        virtual ~AvlArray() {}

        friend std::ostream& operator<<(std::ostream &os, const AvlArray<T> &ar)
        {
            typename std::vector< std::shared_ptr<T> >::const_iterator src = ar.arr.begin();

            while (src != ar.arr.end()) {
                os << **src;
                if (src != ar.arr.end() - 1)
                    os << " ";
                src++;
            }

            return os;
        }

        // subscript operator
        T& operator[](size_t index) { return *arr[index]; }
        const T& operator[](size_t index) const { return *arr[index]; }

        // subscript operator with AvlIndex type
        T& operator[] (AvlIndex &index) {
            index.add_array(this, index_x[index.val()], index_y[index.val()] - 20);
            return *arr[index.val()];
        }

        const T& operator[] (const AvlIndex &index) const {
            return *arr[index.val()];
        }

        // size
        size_t size() const { return arr.size(); }

        // sub-array
        AvlArray<T> subarray(size_t start, size_t end) const
        {
            AvlArray<T> ret(end - start);

            typename std::vector< std::shared_ptr<T> >::const_iterator src = arr.begin() + start;
            typename std::vector< std::shared_ptr<T> >::iterator dst = ret.arr.begin();

            while (src != arr.begin() + end) {
                *dst = *src;
                src++;
                dst++;
            }

            ret.updateMutex = updateMutex;
            ret.toplevelArray = toplevelArray;

            return ret;
        }

        // sub-array with AvlIndex
        AvlArray<T> subarray(const AvlIndex &a, const AvlIndex &b) const
        {
            size_t start = a.val();
            size_t end = b.val();
            AvlArray<T> ret(end - start);

            typename std::vector< std::shared_ptr<T> >::const_iterator src = arr.begin() + start;
            typename std::vector< std::shared_ptr<T> >::iterator dst = ret.arr.begin();

            while (src != arr.begin() + end) {
                *dst = *src;
                src++;
                dst++;
            }

            ret.updateMutex = updateMutex;
            ret.toplevelArray = toplevelArray;

            return ret;
        }

        // render
        virtual void render()
        {
            if (updateMutex->try_lock()) {
                update();
                updateMutex->unlock();
            }

            auxiliary_display();
            

            for (auto& v : arr) {
                v->render();
            }
        }

        void highlight()
        {
            for (auto& v: arr)
                v->highlight();
        }

        void lowlight()
        {
            for (auto& v: toplevelArray->arr)
                v->lowlight();
        }

        // swap two elements in an array
        void swap(size_t idx1, size_t idx2)
        {
            if (!isDisplaying()) {
                T tmp = *arr[idx1];
                *arr[idx1] = *arr[idx2];
                *arr[idx2] = tmp;
                return;
            }

            std::shared_ptr<T> obj[2];
            std::thread moveThread[2];

            obj[0] = arr[idx1];
            obj[1] = arr[idx2];

            updateMutex->lock();

            moveThread[0] = std::thread(moveObject, obj[0], 0, obj[0]->height() * 1.5, DEFAULT_DELAY);
            moveThread[1] = std::thread(moveObject, obj[1], 0, obj[1]->height() * 1.5, DEFAULT_DELAY);
            moveThread[0].join();
            moveThread[1].join();

            moveThread[0] = std::thread(moveObject, obj[0], obj[1]->x() - obj[0]->x(), 0, DEFAULT_DELAY * abs(idx1 - idx2));
            moveThread[1] = std::thread(moveObject, obj[1], obj[0]->x() - obj[1]->x(), 0, DEFAULT_DELAY * abs(idx1 - idx2));
            moveThread[0].join();
            moveThread[1].join();

            moveThread[0] = std::thread(moveObject, obj[0], 0, -obj[0]->height() * 1.5, DEFAULT_DELAY);
            moveThread[1] = std::thread(moveObject, obj[1], 0, -obj[1]->height() * 1.5, DEFAULT_DELAY);
            moveThread[0].join();
            moveThread[1].join();

            T tmp = *arr[idx1];
            *arr[idx1] = *arr[idx2];
            *arr[idx2] = tmp;

            updateMutex->unlock();

            avlSleep(0.1);
        }

        // swap two elements in an array using AvlIndex
        void swap(const AvlIndex &a, const AvlIndex &b)
        {
            size_t idx1 = a.val();
            size_t idx2 = b.val();

            if (!isDisplaying()) {
                T tmp = *arr[idx1];
                *arr[idx1] = *arr[idx2];
                *arr[idx2] = tmp;
                return;
            }

            std::shared_ptr<T> obj[2];
            std::thread moveThread[2];

            obj[0] = arr[idx1];
            obj[1] = arr[idx2];

            updateMutex->lock();

            moveThread[0] = std::thread(moveObject, obj[0], 0, obj[0]->height() * 1.5, DEFAULT_DELAY);
            moveThread[1] = std::thread(moveObject, obj[1], 0, obj[1]->height() * 1.5, DEFAULT_DELAY);
            moveThread[0].join();
            moveThread[1].join();

            moveThread[0] = std::thread(moveObject, obj[0], obj[1]->x() - obj[0]->x(), 0, DEFAULT_DELAY * abs(idx1 - idx2));
            moveThread[1] = std::thread(moveObject, obj[1], obj[0]->x() - obj[1]->x(), 0, DEFAULT_DELAY * abs(idx1 - idx2));
            moveThread[0].join();
            moveThread[1].join();

            moveThread[0] = std::thread(moveObject, obj[0], 0, -obj[0]->height() * 1.5, DEFAULT_DELAY);
            moveThread[1] = std::thread(moveObject, obj[1], 0, -obj[1]->height() * 1.5, DEFAULT_DELAY);
            moveThread[0].join();
            moveThread[1].join();

            T tmp = *arr[idx1];
            *arr[idx1] = *arr[idx2];
            *arr[idx2] = tmp;

            updateMutex->unlock();

            avlSleep(0.1);
        }

        //push
        void push(const T a){
            
            std::shared_ptr<T> current = std::shared_ptr<T> (new T);
            *current = a;
            arr.push_back(current);
            index_x.push_back(0);
            index_y.push_back(0);
            
            update();   
        }

        //pop
        T pop(){
            if(empty())
                return 0;
            else{
                T current = **(arr.end()-1);
                arr.pop_back();
                index_x.pop_back();
                index_y.pop_back();
                
                update();   
                return current;
            }
        }

        //empty
        bool empty(){
            if ( arr.size() == 0)
                return true;
            else
                return false;   
        }

        //dequeue
        T dequeue(){
            if(empty())
                return 0;
            else{
                T current = *arr[0];
                arr.erase(arr.begin());
                index_x.pop_back();
                index_y.pop_back();
                
                update();   
                return current;
                
            }
        }

    private:
        void auxiliary_display() {
            // display "Content"
            unsigned int red = AVL_AUXILIARY_COLOR / 0x10000;
            unsigned int green = AVL_AUXILIARY_COLOR % 0x10000 / 0x100;
            unsigned int blue = AVL_AUXILIARY_COLOR % 0x100;
            glColor4f(red / 255.0, green / 255.0, blue / 255.0, 0.0);

            glRasterPos2f(x() - 9*(name().length() + 2), y());
            glutBitmapString(AvlFont().font(), (const unsigned char *)(std::string(this->name() + ":").c_str()));

            // display "Index" and index 
            glRasterPos2f(x() - 63, y() - 20);
            glutBitmapString(AvlFont().font(), (const unsigned char *)(std::string("Index: ").c_str()));

            for (size_t i = 0; i < arr.size(); i ++) {
                glRasterPos2f(index_x[i], index_y[i]);
                glutBitmapString(AvlFont().font(), (const unsigned char *)(std::to_string(i).c_str()));
            }
        }

        void update()
        {
            float digit_gat = 1.5;

            GLfloat w = -font().width();

            for (typename std::vector< std::shared_ptr<T> >::iterator it = arr.begin();
                    it != arr.end(); it++) {
                if (it == arr.begin()) {
                    (*it)->set_x( x() );
                    (*it)->set_y( y() );
                    (*it)->set_font( font() );
                    w += (*it)->width() + font().width();
                    
                    index_x[it - arr.begin()] = x();
                    index_y[it - arr.begin()] = y() - 20;
                }

                else {
                    (*it)->set_x( (*(it-1))->x() + (*(it-1))->width() + digit_gat * font().width() );
                    (*it)->set_y( (*(it-1))->y() );
                    (*it)->set_font( (*(it-1))->font() );
                    w += (*it)->width() + font().width();

                    index_x[it - arr.begin()] = (*(it-1))->x() + (*(it-1))->width() + digit_gat * font().width();
                    index_y[it - arr.begin()] = (*(it-1))->y() - 20;
                }

            }

            set_width(w);
        }

        std::vector< std::shared_ptr<T> > arr;
        std::shared_ptr<std::mutex> updateMutex;

        // array of the previous level, or parent level
        AvlArray<T> *toplevelArray;

        friend class AvlIndex;

        std::vector<GLfloat> index_x;
        std::vector<GLfloat> index_y;
}; //end of AvlArray

class AvlBool: public AvlObject
{
    public:
        // constructor
        AvlBool(bool v = false, GLfloat x = 0, GLfloat y = 0, void *font = GLUT_BITMAP_9_BY_15)
            : AvlObject(x, y, font)
        {
            value = v;
        }

        // destructor
        virtual ~AvlBool() {}

        // assignment operator
        const AvlBool& operator=(bool v) { value = v; return *this; }

        // << operator
        friend std::ostream& operator<<(std::ostream &os, const AvlBool &v)
        {
            os << v.value;
            return os;
        }

        // unary operator
        const AvlBool operator!() const
        {
            AvlBool ret = *this;
            ret.value = !value;
            return ret;
        }

        // comparison operators
        bool operator==(bool v) const { return value == v; }
        bool operator==(const AvlBool &v) const { return value == v.value; }
        friend bool operator==(bool v1, const AvlBool v2) { return v1 == v2.value; }

        bool operator!=(bool v) const { return value != v; }
        bool operator!=(const AvlBool &v) const { return value != v.value; }
        friend bool operator!=(bool v1, const AvlBool v2) { return v1 != v2.value; }

        bool operator&&(bool v) const { return value && v; }
        bool operator&&(const AvlBool &v) const { return value && v.value; }
        friend bool operator&&(bool v1, const AvlBool v2) { return v1 && v2.value; }

        bool operator||(bool v) const { return value || v; }
        bool operator||(const AvlBool &v) const { return value || v.value; }
        friend bool operator||(bool v1, const AvlBool v2) { return v1 || v2.value; }

        // value getter
        bool val() const { return value; }

        // render function
        virtual void render()
        {
            unsigned int red = color() / 0x10000;
            unsigned int green = color() % 0x10000 / 0x100;
            unsigned int blue = color() % 0x100;
            glColor4f(red / 255.0, green / 255.0, blue / 255.0, 0.0);

            glRasterPos2f(x(), y());
            std::string display_value = value ? "T" : "F";
            glutBitmapString(font().font(), (const unsigned char *)display_value.c_str());
        }

        void highlight() { 
            set_color(AVL_COLOR_HIGHLIGHT); 
        }
        void lowlight() { 
            set_color(AVL_COLOR_DEFAULT); 
        }

    private:
        bool value;
}; // end of AvlBool


#endif // AVL_TYPES_H_



file: avl/lib/AvlUtils.h

#ifndef AVL_UTILS_H_
#define AVL_UTILS_H_

#include <thread>
#include <chrono>

inline void avlSleep(float seconds)
{
    int ms = seconds * 1000;
    std::chrono::duration<int, std::milli> milliseconds(ms);

    std::this_thread::sleep_for(milliseconds);
}

#endif // AVL_UTILS_H_



file: avl/lib/AvlVisualizer.cpp

#include "AvlVisualizer.h"
#include "AvlTypes.h"

int AvlVisualizer::currentWidth = 0;
int AvlVisualizer::currentHeight = 0;
std::unordered_map<std::string, AvlObject *> AvlVisualizer::objects;
std::atomic<int> AvlVisualizer::level(0);
std::stack<int> AvlVisualizer::levelBackup;

AvlVisualizer::AvlVisualizer(int argc, char *argv[])
{
    glutInit(&argc, argv);

    glutInitContextVersion(OpenGL_Major_Version, OpenGL_Minor_Version);
    glutInitContextFlags(GLUT_FORWARD_COMPATIBLE);
    glutInitContextProfile(GLUT_CORE_PROFILE);

    glutSetOption(GLUT_ACTION_ON_WINDOW_CLOSE, GLUT_ACTION_GLUTMAINLOOP_RETURNS);

    glutInitWindowSize(Default_Width, Default_Height);
    glutInitDisplayMode(GLUT_DEPTH | GLUT_DOUBLE | GLUT_RGBA);

    windowHandle = glutCreateWindow(Title);

    glutReshapeFunc(AvlVisualizer::avlResize);
    glutDisplayFunc(AvlVisualizer::avlDisplay);

    glClearColor(0.0, 0.0, 0.0, 0.0);
}

AvlVisualizer::~AvlVisualizer()
{
}

void AvlVisualizer::show()
{
    glutMainLoop();
}

void AvlVisualizer::start()
{
    level++;
}

void AvlVisualizer::stop()
{
    level--;
}

void AvlVisualizer::reset()
{
    levelBackup.push(level.load());
    level.store(0);
}

void AvlVisualizer::restore()
{
    level.store(levelBackup.top());
    levelBackup.pop();
}

int AvlVisualizer::getLevel() const
{
    return level.load();
}

void AvlVisualizer::addObject(AvlObject *obj, const std::string &name)
{
    if (objects.find(name) == objects.end()) {
        objects[name] = obj;
        obj->setVisualizer(this);
    }

    placeObject();
}

void AvlVisualizer::delObject(const std::string &name)
{
    if (objects.find(name) != objects.end())
        objects.erase(name);

    placeObject();
}

void AvlVisualizer::placeObject()
{
    std::vector<AvlObject *> arrays;
    std::vector<AvlObject *> others;

    for (auto& o : objects) {
        AvlObject *obj = o.second;
        if (typeid(*obj) == typeid(AvlArray<AvlInt>) || typeid(*obj) == typeid(AvlArray<AvlChar>)
                || typeid(*obj) == typeid(AvlArray<AvlBool>))
            arrays.push_back(obj);
        else {
            if (typeid(*obj) != typeid(AvlIndex))
                others.push_back(obj);
        }
    }

    if (!arrays.empty()) {
        int h = Default_Height / arrays.size() / 2;
        for (size_t i = 0; i < arrays.size(); i++) {
            arrays[i]->lock();
            int x = -arrays[i]->width() / 2;
            int y = h * (int(arrays.size()) / 2 - i);
            arrays[i]->set_x(x);
            arrays[i]->set_y(y);
            arrays[i]->unlock();
        }
    }

    if (!others.empty()) {
        int w = Default_Width / others.size() / 2;
        for (size_t i = 0; i < others.size(); i++) {
            others[i]->lock();
            int x = w * (int(others.size() / 2) - i);
            int y = Default_Height / 2 - AvlFont().height() * 2;
            others[i]->set_x(x);
            others[i]->set_y(y);
            others[i]->unlock();
        }
    }
}

void AvlVisualizer::avlResize(int width, int height)
{
    GLdouble size;
    GLdouble aspect;

    glViewport(0, 0, width, height);

    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    size = (GLdouble)(width >= height ? width : height) / 2.0;
    if (width <= height) {
        aspect = (GLdouble)height / (GLdouble)width;
        glOrtho(-size, size, -size*aspect, size*aspect, -100000.0, 100000.0);
    }
    else {
        aspect = (GLdouble)width / (GLdouble)height;
        glOrtho(-size*aspect, size*aspect, -size, size, -100000.0, 100000.0);
    }

    glScaled(aspect, aspect, 1.0);

    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
}

void AvlVisualizer::avlDisplay()
{
    if (level.load() > 0) {
        glClearColor(0.0, 0.0, 0.0, 0.0);
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

        for (auto& obj : objects)
            obj.second->render();
    }

    glutSwapBuffers();
    glutPostRedisplay();
}



file: avl/lib/AvlVisualizer.h

#ifndef AVL_VISUALIZER_H_
#define AVL_VISUALIZER_H_

#include <GL/freeglut.h>
#include <GL/glut.h>
#include <unordered_map>
#include <stack>
#include <string>
#include <atomic>

const int OpenGL_Major_Version = 2;
const int OpenGL_Minor_Version = 1;
const char *const Title = "Algorithm Visualization";
const int Default_Width = 640;
const int Default_Height = 480;

class AvlObject;

class AvlVisualizer
{
    public:
        AvlVisualizer(int argc, char *argv[]);
        ~AvlVisualizer();

        void show();

        void addObject(AvlObject *obj, const std::string &name);
        void delObject(const std::string &name);

        void start();
        void stop();
        void reset();
        void restore();
        int getLevel() const;

    private:
        static void avlResize(int width, int height);
        static void avlDisplay();

        void placeObject();

        int windowHandle;
        static int currentWidth;
        static int currentHeight;

        static std::unordered_map<std::string, AvlObject *> objects;

        static std::atomic<int> level;
        static std::stack<int> levelBackup;
};

#endif // AVL_VISUALIZER_H_



file: avl/lib/Makefile.am

lib_LTLIBRARIES = libavl.la
libavl_la_SOURCES = AvlVisualizer.cpp
include_HEADERS = AvlVisualizer.h AvlTypes.h AvlUtils.h
AM_CPPFLAGS = -Wall -Wextra -Werror -std=c++11 -I/opt/local/include



file: avl/m4/.gitignore

# Ignore everything in this directory
*
# Except this file
!.gitignore



file: avl/Makefile.am

ACLOCAL_AMFLAGS = -I m4
SUBDIRS = src lib sample_code tests



file: avl/README.md

AVL
===
Please see [Issues](https://github.com/wqfish/avl/issues) for bugs and creating new tasks.

How to build
============

1. Prerequisites
    - Mac
        * Setup [MacPorts](http://guide.macports.org)
        * Install [XQuartz](https://xquartz.macosforge.org/)
        * Install dependencies
        ```bash
        sudo port install astyle automake libtool freeglut glew glm glfw
        ```
    - Linux
        * Only need to install libraries
        ```bash
        sudo apt-get install **
        ```

2. Create configure script.
    ```bash
    autoreconf --install
    ```

3. Create Makefiles.
    ```bash
    ./configure
    ```

4. Make.
    ```bash
    make
    ```

5. Install
    ```bash
    sudo make install
    ```
This would install avl to /usr/local/bin, header files to /usr/local/include
and libraries to /usr/local/lib.

How to run test cases
=====================

```bash
make check
```
You can run ```make check -j [N]``` if you have multiple CPUs.

How to add a test case
======================

Suppose you want to test ```if``` control flow.

1. Create ```if1.avl``` in ```tests/avl.test/```, assuming you have multiple test cases for ```if```.

2. Write a bash script ```if1.sh```, also put it into ```tests/avl.test/```:
    ```bash
    #!/bin/bash
    
    avl -o if1 if1.avl
    ```
Don't forget ```chmod +x if1.sh```. If the test case is expected to fail, the bash script
should be as follows:
    ```bash
    #!/bin/bash
    
    avl -t if1.avl
    ```
since the error should be reported before invoking `g++`.

3. Modify ```tests/avl.test/Makefile.am```, add ```if1.sh``` to ```TESTS``` variable.
If the test case is expected to fail, also add the script to ```XFAIL_TESTS``` variable.
Whether the test case passes or fails depends on the exit code of the script (0 for success).

4. Rerun ```make check```.



file: avl/sample_code/.gitignore

sorting
merge_sorted_array



file: avl/sample_code/Makefile.am

noinst_PROGRAMS = sorting merge_sorted_array
sorting_SOURCES = sorting.cpp
merge_sorted_array_SOURCES = merge_sorted_array.cpp

AM_CPPFLAGS = -Wall -Werror -std=c++11 -I$(top_builddir)/lib -I/opt/local/include
AM_LDFLAGS = -L$(top_builddir)/lib -L/opt/local/lib -lavl -lGL -lglut



file: avl/sample_code/merge_sorted_array.avl

/* merge two sorted array @a and @b
 * and store the result in @c */

void merge(int a[], int b[], int c[])
{
    <begin_display>

    display index i = 0;
    display index j = 0;
    display index k = 0;

    while (true) {
        if (i >= len(a) || j >= len(b))
            break;

        if (a[i] < b[j]) {
            swap(a, i, i);
            c[k] = a[i++];
        }
        else {
            swap(b, j, j);
            c[k] = b[j++];
        }

        k++;
    }

    for (i ; i < len(a); i++) {
        swap(a, i, i);
        c[k] = a[i];
        k++;
    }
    for (j; j < len(b); j++) {
        swap(b, j, j);
        c[k] = b[j];
        k++;
    }

    <end_display>
}

int main()
{
    <begin_display>

    display int a[] = {1, 5, 7, 9, 20};
    display int b[] = {2, 4, 8, 16};
    display int c[9];

    merge(a, b, c);

    <end_display>

    print c;

    return 0;
}



file: avl/sample_code/merge_sorted_array.cpp

#include <AvlVisualizer.h>
#include <AvlTypes.h>
#include <condition_variable>
#include <cstdlib>

AvlVisualizer *__avl__vi = NULL;
bool __avl__ready() { return __avl__vi != NULL; }
std::mutex __avl__mtx;
std::condition_variable_any __avl__cv;

void __avl__display(int argc, char **argv)
{
    __avl__mtx.lock();
    __avl__vi = new AvlVisualizer(argc, argv);
    __avl__cv.notify_one();
    __avl__mtx.unlock();

    __avl__vi->show();
}

void merge(AvlArray<AvlInt> a, AvlArray<AvlInt> b, AvlArray<AvlInt> c)
{
    __avl__vi->reset();
    a.lowlight();
    a.highlight();
    b.lowlight();
    b.highlight();
    c.lowlight();
    c.highlight();

    __avl__vi->start();
    avlSleep(0.5);

    AvlIndex i = 0;
    i.set_name("i");
    __avl__vi->addObject(&i, "i");
    AvlIndex j = 0;
    j.set_name("j");
    __avl__vi->addObject(&j, "j");
    AvlIndex k = 0;
    k.set_name("k");
    __avl__vi->addObject(&k, "k");

    while (true) {
        if (i >= a.size() || j >= b.size())
            break;

        c[k].assign(a[i] < b[j] ? a[i++] : b[j++]);
        k++;
    }

    for (; i < a.size(); i++) {
        c[k].assign(a[i]);
        k++;
    }
    for (; j < b.size(); j++) {
        c[k].assign(b[j]);
        k++;
    }

    avlSleep(0.1);
    __avl__vi->stop();

    __avl__vi->delObject("i");
    __avl__vi->delObject("j");
    __avl__vi->delObject("k");

    a.lowlight();
    b.lowlight();
    c.lowlight();
    __avl__vi->restore();
}

int main(int argc, char *argv[])
{
    std::thread __avl__loop(__avl__display, argc, argv);
    __avl__mtx.lock();
    __avl__cv.wait(__avl__mtx, __avl__ready);
    __avl__mtx.unlock();
    avlSleep(0.5);

    __avl__vi->start();
    avlSleep(0.5);

    AvlArray<AvlInt> a = {1, 5, 7, 9, 20};
    a.set_name("a");
    __avl__vi->addObject(&a, "a");
    AvlArray<AvlInt> b = {2, 4, 8, 16};
    b.set_name("b");
    __avl__vi->addObject(&b, "b");
    AvlArray<AvlInt> c(9);
    c.set_name("c");
    __avl__vi->addObject(&c, "c");

    merge(a, b, c);

    avlSleep(0.1);
    __avl__vi->stop();

    std::cout << c << std::endl;

    __avl__vi->delObject("a");
    __avl__vi->delObject("b");
    __avl__vi->delObject("c");

    __avl__loop.join();
    delete __avl__vi;

    return 0;
}



file: avl/sample_code/sorting.avl

void quicksort(int a[])
{
    if (len(a) <= 1)
        return;

    index i = 0;
    index j = 0;
    index k = len(a) - 1;

    <begin_display>
    while (j < k) {
        if (a[j] >= a[k]) {
            j = j + 1;
        }
        else {
            swap(a, i, j);
            i = i + 1;
            j++;
        }
    }

    swap(a, i, k);

    quicksort(a[0 : i]);
    quicksort(a[(i + 1) : (k + 1)]);
    <end_display>
}

void randomPermute(int a[])
{
    for (index i = 0; i < len(a); i++) {
        index j = rand() % len(a);
        swap(a, i, j);
    }
}

int main() {
    display int a[] = {5, 51, 2, 42, 7, 3, 6, 8, 10, 3, 11, 5, 9};

    print "before sorting: ", a;

    <begin_display>
    for (index i = 1; i < len(a); i++) {
        index j = i - 1;
        while (j >= 0 && a[j] > a[j+1]) {
            swap(a, j + 1, j);
            j = j - 1;
        }
    }

    print "after bubblesort: ", a;

    randomPermute(a);

    print "after permutation: ", a;

    quicksort(a);

    print "after quicksort: ", a;

    <end_display>

    return 0;
}



file: avl/sample_code/sorting.cpp

/* Headers:
 * insert the following lines at the beginning of
 * each target C++ file */
#include <AvlVisualizer.h>
#include <AvlTypes.h>
#include <condition_variable>
#include <cstdlib>

/* Note: these variable names are also reserved words,
 * so we add a prefix __avl__. */
AvlVisualizer *__avl__vi = NULL;
bool __avl__ready() { return __avl__vi != NULL; }
std::mutex __avl__mtx;
std::condition_variable_any __avl__cv;

void __avl__display(int argc, char **argv)
{
    __avl__mtx.lock();
    __avl__vi = new AvlVisualizer(argc, argv);
    __avl__cv.notify_one();
    __avl__mtx.unlock();

    __avl__vi->show();
}
/* End of Headers */


/* User defined function:
 * NOTE: the parameters should be passed by value */
void quicksort(AvlArray<AvlInt> a)
{
    /* Insert the following three lines at the
     * beginning of each function except main() */
    __avl__vi->reset();
    a.lowlight();
    a.highlight();

    /* len(a) -> a.size() */
    if (a.size() <= 1) {
        /* NOTE: 'return' is equivalent to end of function
         * so the following two lines are needed. Additional
         * '{' and '}' are also required.
         * !!!FIXME!!!: Is a return between <begin_display> and
         * <end_display> allowed? Seems no problem. */
        a.lowlight();
        __avl__vi->restore();
        return;
    }

    /* Translate type index to AvlIndex,
     * index should be non-negative */
    AvlIndex i = 0;
    i.set_name("i");
    AvlIndex j = 0;
    j.set_name("j");
    AvlIndex k = a.size() - 1;
    k.set_name("k");


    /* substitude <begin_display> with the following two lines */
    __avl__vi->start();
    avlSleep(0.5);

    while (j < k) {
        if (a[j] >= a[k]) {
            j = j + 1;
        }
        else {
            /* swap(a, i, j) -> a.swap(i, j) */
            a.swap(i, j);
            i = i + 1;
            j++;
        }
    }

    /* same as above */
    a.swap(i, k);

    /* translation rule for subarrys,
     * TODO: operator precedence? ':' and '+-' */
    quicksort(a.subarray(0, i));
    quicksort(a.subarray((i+1), (k+1)));

    /* substitude <end_display> with the following two lines */
    avlSleep(0.1);
    __avl__vi->stop();

    /* Insert the following two lines at the end of each function */
    a.lowlight();
    __avl__vi->restore();
}

/* This is an example of user defined function
 * which does not contain <begin_display> and
 * <end_display>, it should not be displayed */
void randomPermute(AvlArray<AvlInt> a)
{
    /* Insert the following three lines at the
     * beginning of each function except main */
    __avl__vi->reset();
    a.lowlight();
    a.highlight();

    /* !!FIXME!!
     * To Shining Sun:
     * we cannot translate "index i = 0" to
     * "AvlIndex i = 0; i.set_name("i")" here. */
    for (AvlIndex i = 0; i < a.size(); i++) {
        /* Should rand be a keyword or a function?
         * If function, consider inline C (like inline
         * assembly in C) */
        AvlIndex j = rand() % a.size();
        j.set_name("j");
        a.swap(i, j);
    }

    /* Insert the following two lines at the end of each function */
    a.lowlight();
    __avl__vi->restore();
}

/* main:
 * NOTE: argc and argv are required */
int main(int argc, char *argv[])
{
    /* only for main:
     * insert the following five lines at the beginning of main */
    std::thread __avl__loop(__avl__display, argc, argv);
    __avl__mtx.lock();
    __avl__cv.wait(__avl__mtx, __avl__ready);
    __avl__mtx.unlock();
    avlSleep(0.5);



    /* substitude array declaration with the following two lines */
    AvlArray<AvlInt> a = {5, 51, 2, 42, 7, 3, 6, 8, 10, 3, 11};

    a.set_name("a");
    /* If the variable should be displayed, the following line is needed */
    __avl__vi->addObject(&a, "a");

    /* translation rule for print */
    std::cout << "before sorting: " << a << std::endl;

    /* 1. Insertion Sort */

    /* substitude <begin_display> with the following two lines */
    __avl__vi->start();
    avlSleep(0.5);

    /* !!FIXME!!
     * same issue as in randomPermute */
    for (AvlIndex i = 1; i < a.size(); i++) {
        i.set_name("i");
        __avl__vi->addObject(&i, "i");
        AvlIndex j = i - 1;
        j.set_name("j");
        __avl__vi->addObject(&j, "j");
        while (j >= 0 && a[j] > a[j+1]) {
            a.swap(j + 1, j);
            j = j - 1;
        }
    }
    
    std::cout << "after insertion sort: " << a << std::endl;

    /* 2. random permutation */

    /* This function won't be displayed, although it is
     * put between <begin_display> and <end_display> */
    randomPermute(a);

    std::cout << "after permutation: " << a << std::endl;

    /* 3. quicksort */

    /* substitude <begin_display> with the following two lines */
    __avl__vi->start();
    avlSleep(0.5);


    quicksort(a);

    std::cout << "after quicksort: " << a << std::endl;

    /* substitude <end_display> with the following two lines */
    avlSleep(0.1);
    __avl__vi->stop();

    /* only for main:
     * insert the following two lines at the end of main
     * BEFORE return 0 */
    __avl__loop.join();
    delete __avl__vi;

    return 0;
}



file: avl/src/.gitignore

avl
parser.h
parser.c
parser.output
scanner.c



file: avl/src/avl.c

#include <sys/stat.h>
#include <sys/wait.h>
#include <unistd.h>
#include <getopt.h>
#include <string.h>
#include <stdlib.h>
#include <stdarg.h>
#include <stdio.h>
#include "config.h"
#include "syntax_tree.h"

int yyparse();

const char *const USAGE =
    "Usage: " PACKAGE " [-h|-o|-t] file\n"
    "Options:\n"
    "  -h --help                Display this information\n"
    "  -o --output=<file>       Compile and place the executable into <file>\n"
    "  -t --translate           Translate the source files into c++\n"
    "                           xxx.avl -> xxx.cpp\n"
    "Use at most one option at a time.\n"
    "\n"
    "For bug reporting instructions, please see:\n"
    "<" PACKAGE_URL ">.\n";

#define MAX_FILENAME 256
char input_file[MAX_FILENAME];
char output_file[MAX_FILENAME];
char translate_file[MAX_FILENAME];
char temp_file[MAX_FILENAME];
char format_file[MAX_FILENAME];
int translate_flag = 0;
int output_flag = 0;

extern FILE *yyin;
extern FILE *yyout;

const char *const DEFAULT_OUTPUT = "a.out";
const char *const DEFAULT_EXT = ".avl";
const char *const TRANSLATE_EXT = ".cpp";
const char *const DEFAULT_TEMP = "/tmp/avl_temp.XXXXXX";
char *const CXX_OPTIONS[] = {
    "g++",
    "-x",
    "c++",
    "-std=c++11",
    "-Wall",
    "-o",
    output_file,
    temp_file,
    "-I/opt/local/include",
    "-I/usr/include",
    "-I/usr/local/include",
    "-L/opt/local/lib",
    "-L/usr/lib",
    "-L/usr/local/lib",
    "-lavl",
    "-lGL",
    "-lglut",
    NULL
};
char *const ASTYLE_OPTIONS[] = {
    "astyle",
    "--style=linux",
    "--suffix=none",
    format_file,
    NULL
};

const struct option long_options[] = {
    {"help",      no_argument,       NULL, 'h'},
    {"output",    required_argument, NULL, 'o'},
    {"translate", no_argument,       NULL, 't'},
    {0, 0, 0, 0}
};

void usage()
{
    fprintf(stderr, "%s", USAGE);
}

void die(const char *format, ...)
{
    va_list ap;

    va_start(ap, format);
    fprintf(stderr, PACKAGE ": ");
    vfprintf(stderr, format, ap);
    fprintf(stderr, "\n");
    va_end(ap);

    exit(EXIT_FAILURE);
}

void die_err(const char *msg)
{
    perror(msg);
    exit(EXIT_FAILURE);
}

void parse_command_line(int argc, char *argv[])
{
    memset(input_file, 0, MAX_FILENAME);
    memset(output_file, 0, MAX_FILENAME);
    memset(translate_file, 0, MAX_FILENAME);
    memset(temp_file, 0, MAX_FILENAME);
    memset(format_file, 0, MAX_FILENAME);
    strcpy(output_file, DEFAULT_OUTPUT);
    strcpy(temp_file, DEFAULT_TEMP);

    while (1) {
        int option_index = 0;
        char c = getopt_long(argc, argv, "ho:t", long_options, &option_index);
        if (c == -1)
            break;

        switch (c) {
            case 'h':
                usage();
                exit(EXIT_SUCCESS);
            case 'o':
                if (!optarg) {
                    usage();
                    exit(EXIT_FAILURE);
                }
                if (strlen(optarg) <= 0)
                    die("no output filename.");
                else if (strlen(optarg) >= MAX_FILENAME)
                    die("output filename too long: %s.", optarg);
                strcpy(output_file, optarg);
                output_flag = 1;
                break;
            case 't':
                translate_flag = 1;
                break;
            default:
                usage();
                exit(EXIT_FAILURE);
        }
    }

    if (output_flag && translate_flag)
        die("Please specify at most one option at a time.");

    if (optind != argc - 1) {
        usage();
        exit(EXIT_FAILURE);
    }
    if (strlen(argv[optind]) <= strlen(DEFAULT_EXT)
            || strlen(argv[optind]) >= MAX_FILENAME)
        die("invalid input filename: %s.", argv[optind]);
    strcpy(input_file, argv[optind]);
    if (strcmp(input_file + strlen(input_file) - strlen(DEFAULT_EXT),
                DEFAULT_EXT) != 0)
        die("not a valid avl source file: %s.", input_file);

    struct stat buf;
    if (stat(input_file, &buf) != 0)
        die_err("invalid input file");

    if (translate_flag) {
        strcpy(translate_file, input_file);
        strcpy(translate_file + strlen(translate_file) - strlen(DEFAULT_EXT),
                TRANSLATE_EXT);
    }
}

void execute_program(char *const *options)
{
    pid_t pid = fork();

    if (pid < 0)
        die_err("fork() failed");
    else if (pid == 0) {
        char *const *s = options;
        while (*s)
            printf("%s ", *s++);
        printf("\n");

        if (execvp(options[0], options) < 0)
            die_err("execvp() failed");
    }

    int status;
    if (waitpid(pid, &status, 0) != pid)
        die_err("waitpid() failed");
    if (WEXITSTATUS(status))
        die("failed to execute %s.", options[0]);
}

int main(int argc, char *argv[])
{
    parse_command_line(argc, argv);

    yyin = fopen(input_file, "r");
    if (!yyin)
        die_err("can not open input file");

    if (translate_flag) {
        yyout = fopen(translate_file, "w");
        if (!yyout)
            die_err("can not open translate file");
    }
    else {
        int fd = mkstemp(temp_file);
        if (fd < 0)
            die_err("mkstemp() failed");
        yyout = fdopen(fd, "w");
        if (!yyout)
            die_err("can not open temporary file");
    }

    if (yyparse() != 0)
        die("Parsing failed.");

    fclose(yyin);
    fclose(yyout);

    /* code formatting */
    if (translate_flag)
        strcpy(format_file, translate_file);
    else
        strcpy(format_file, temp_file);

    execute_program(ASTYLE_OPTIONS);

    /* invoking g++ */
    if (!translate_flag)
        execute_program(CXX_OPTIONS);

    return 0;
}



file: avl/src/code_generator.c

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "syntax_tree.h"
#include "st_list.h"
#include "sym_table.h"

void freeTree(nodeType* node);
int generateOpNode(oprNode* opr);
int generateSubtree(nodeType* node);
void print_append(char* s, int space);
void print_append_int(int value, int space);
void print_indent();
void print_header();
void print_line(const char *line);
void avl_code_generator(nodeType* root);

int newLine = 1;
int indent = 0;
extern FILE *yyout;
char** paraList;
int paraCount;
int mainFun;
int needSleep;

// function for generate code from syntax tree rooted at nodeType* root
void avl_code_generator(nodeType* root) {
    printf("begin translate.\n");
    print_header();
    paraList = NULL;
    int ret = generateSubtree(root);
    freeTree(root);
    if (ret == 0) {
        printf("Succeed\n");
    } else {
        printf("Fail\n");
    }
}

// count nunber of paramenters of a function
int numPara(oprNode* node) {
    if (node->opType == concatenate)
        return numPara(&node->op[0]->opr) + 1;
    return 1;
}

// generate code for the tree rooted at node (called recursively)
int generateSubtree(nodeType* node) {
    switch (node->type) {
        // leaf node
        case INTCON_NODE:
            print_append_int(node->intCon.value, 1);
            break;
        case CHARCON_NODE:
            print_append(node->charCon.value, 1);
            break;
        case BOOLCON_NODE:
            if (node->boolCon.value)
                print_append("true", 1);
            else
                print_append("false", 1);
            break;
        case STRLIT_NODE:
            print_append(node->strLit.value, 1);
            break;
        case VARTYPE_NODE:
            switch (node->varType.value) {
                case VOID_TYPE:
                    print_append("void", 1);
                    break;
                case CHAR_TYPE:
                    print_append("AvlChar", 1);
                    break;
                case INT_TYPE:
                    print_append("AvlInt", 1);
                    break;
                case STRING_TYPE:
                    print_append("std::string", 1);
                    break;
                case INDEX_TYPE:
                    print_append("AvlIndex", 1);
                    break;
                case BOOL_TYPE:
                    print_append("AvlBool", 1);
                    break;
            }
            break;
        case ID_NODE:
            print_append(node->id.value, 1);
            break;
        case MATHOP_NODE:
            print_append(node->mathOp.value, 1);
            break;
        // inner node
        case OPERATOR_NODE:
            if(generateOpNode(&node->opr)) return 1;
            break;
    }
    return 0;
}

// generate code for a tree rooted at an operation node (inner node)
int generateOpNode(oprNode* opr) {
    int i;
    char* id;
    nodeType* temp;
    switch (opr->opType) { // operation node type
        case parentheses_exp:
            print_append("(", 1);
            if (generateSubtree(opr->op[0])) return 1;
            print_append(")", 1);
            break;
        case array:
            if (generateSubtree(opr->op[0])) return 1;
            if (opr->numOperands == 2) {
                print_append("[", 0);
                if (generateSubtree(opr->op[1])) return 1;
                print_append("]", 1);
            } else {
                print_append(".subarray(", 0);
                if (generateSubtree(opr->op[1])) return 1;
                print_append(",", 0);
                if (generateSubtree(opr->op[2])) return 1;
                print_append(")", 1);
            }
            break;
        case func_call:
            if (generateSubtree(opr->op[0])) return 1;
            print_append("(", 0);
            if (opr->numOperands == 2 && generateSubtree(opr->op[1])) return 1;
            print_append(")", 1);
            break;
        case concatenate:
            if (generateSubtree(opr->op[0])) return 1;
            print_append(",", 0);
            if (generateSubtree(opr->op[1])) return 1;
            break;
        case math_op:
            for (i=0; i<opr->numOperands; i++) {
                if (generateSubtree(opr->op[i])) return 1;
            }
            break;
        case len:
            if (generateSubtree(opr->op[0])) return 1;
            print_append(".size()", 0);
            break;
        case assignment:    
            if (generateSubtree(opr->op[0])) return 1;
            print_append("=", 1);
            if (generateSubtree(opr->op[1])) return 1;
            break;
        case disp_exp:
            if (opr->op[0]->type != ID_NODE) return 1;
            print_indent();
            fprintf(yyout, "__avl__vi->addObject(&%s, \"%s\")", opr->op[0]->id.value, opr->op[0]->id.value);
            break;
        case hide_exp:
            if (opr->op[0]->type != ID_NODE) return 1;
            print_indent();
            fprintf(yyout, "__avl__vi->delObject(\"%s\")", opr->op[0]->id.value);
            break;
        case swap:
            if (generateSubtree(opr->op[0])) return 1;
            print_append(".swap(", 0);
            if (generateSubtree(opr->op[1])) return 1;
            print_append(",", 0);
            if (generateSubtree(opr->op[2])) return 1;
            print_append(")", 1);
            break;
        case print:
            print_append("std::cout << (", 1);
            if (generateSubtree(opr->op[0])) return 1;
            print_append(") << std::endl", 1);
            break;
        case print_list:
            if (generateSubtree(opr->op[0])) return 1;
            if (opr->numOperands == 2) {
                print_append(") << (", 1);
                if (generateSubtree(opr->op[1])) return 1;
            }
            break;
        case var_decl:
        case var_decl_disp:
        case var_decl_hide:
            // whether is an array
            temp = opr->op[1];
            while (temp->type == OPERATOR_NODE) {
                if (temp->opr.opType == arr_decl) break;
                temp = temp->opr.op[0];
            }
            if (temp->opr.opType == arr_decl) { // is array
                print_append("AvlArray<", 1);
                if (generateSubtree(opr->op[0])) return 1;
                print_append(">", 0);
                if (generateSubtree(temp->opr.op[0])) return 1;
                if (temp->opr.numOperands == 2) {
                    if (!(opr->op[1]->type == OPERATOR_NODE && opr->op[1]->opr.opType == assignment)) {
                        print_append("(", 0);
                        if (generateSubtree(temp->opr.op[1])) return 1;
                        print_append(")", 0);
                    }
                }
            } else { // not array
                if (generateSubtree(opr->op[0])) return 1;
                if (generateSubtree(temp)) return 1;
            }
            // assignment
            if (opr->op[1]->type == OPERATOR_NODE && opr->op[1]->opr.opType == assignment) {
                print_append("=", 1);
                if (generateSubtree(opr->op[1]->opr.op[1])) return 1;
            }
            print_append(";", 0);
            newLine = 1;
            // id to temp
            while (temp->type == OPERATOR_NODE) {
                temp = temp->opr.op[0];
            }
            id = temp->id.value;
            print_indent();
            if (opr->op[0]->varType.value == STRING_TYPE)
                break;
            fprintf(yyout, "%s.set_name(\"%s\");\n", id, id);
            if (opr->opType == var_decl_disp) {
                print_indent();
                fprintf(yyout, "__avl__vi->addObject(&%s, \"%s\");\n",id, id);
            }
            newLine = 1;
            break;
        case arr_decl:
            if (generateSubtree(opr->op[0])) return 1;
            break;
        case init_list:
            print_append("{", 1);
            if (generateSubtree(opr->op[0])) return 1;
            print_append("}", 1);
            break;
        case empty_state:
            print_append(";", 0);
            newLine = 1;
            break;
        case exp_state:
            if (needSleep) print_append("avlSleep(0.15);", 1);
            newLine = 1;
            if (generateSubtree(opr->op[0])) return 1;
            print_append(";", 0);
            newLine = 1;
            if (needSleep) print_append("avlSleep(0.15);", 1);
            newLine = 1;
            break;
        case declar_state:
            if (generateSubtree(opr->op[0])) return 1;
            break;
        case comp_state:
            print_append("{", 1);
            newLine = 1;
            indent ++;
            if (opr->numOperands == 1 && generateSubtree(opr->op[0])) return 1;
            indent --;
            print_append("}", 0);
            newLine = 1;
            break;
        case state_list:
            if (generateSubtree(opr->op[0])) return 1;
            if (generateSubtree(opr->op[1])) return 1;
            break;
        case display_state:
            needSleep ++;
            print_append("__avl__vi->start();", 1);
            newLine = 1;
            print_append("avlSleep(0.5);", 0);
            newLine = 1;
            if (generateSubtree(opr->op[0])) return 1;
            needSleep --;
            print_append("avlSleep(0.1);", 1);
            newLine = 1;
            print_append("__avl__vi->stop();", 0);
            newLine = 1;
            break;
        case select_state:
            print_append("if (", 1);
            if (generateSubtree(opr->op[0])) return 1;
            print_append(")", 1);
            if (opr->op[1]->type == OPERATOR_NODE && opr->op[1]->opr.opType != comp_state) {
                print_append("{", 1);
                newLine = 1;
                indent ++;
                if (generateSubtree(opr->op[1])) return 1;
                indent --;
                print_append("}", 0);
                newLine = 1;
            } else {
                if (generateSubtree(opr->op[1])) return 1;
            }
            if (opr->numOperands == 3) {
                print_append("else", 1);
                if (opr->op[2]->type == OPERATOR_NODE && opr->op[2]->opr.opType != comp_state) {
                    print_append("{", 1);
                    newLine = 1;
                    indent ++;
                    if (generateSubtree(opr->op[2])) return 1;
                    indent --;
                    print_append("}", 0);
                    newLine = 1;
                } else {
                    if (generateSubtree(opr->op[2])) return 1;
                }
            }
            break;
        case while_state:
            print_append("while (", 1);
            if (generateSubtree(opr->op[0])) return 1;
            print_append(")", 1);
            if (opr->op[1]->type == OPERATOR_NODE && opr->op[1]->opr.opType != comp_state) {
                print_append("{", 1);
                newLine = 1;
                indent ++;
                if (generateSubtree(opr->op[1])) return 1;
                indent --;
                print_append("}", 0);
                newLine = 1;
            } else {
                if (generateSubtree(opr->op[1])) return 1;
            }
            break;
        case do_while_state:
            print_append("do", 1);
            if (opr->op[0]->type == OPERATOR_NODE && opr->op[0]->opr.opType != comp_state) {
                print_append("{", 1);
                newLine = 1;
                indent ++;
                if (generateSubtree(opr->op[0])) return 1;
                indent --;
                print_append("}", 0);
                newLine = 1;
            } else {
                if (generateSubtree(opr->op[0])) return 1;
            }
            print_append("while (", 1);
            if (generateSubtree(opr->op[1])) return 1;
            print_append(");", 1);
            newLine = 1;
            break;
        case for_state:
            //declare in for
            if (opr->op[0]->opr.opType == var_decl ||opr->op[0]->opr.opType == var_decl_disp || opr->op[0]->opr.opType == var_decl_hide) {
                print_append("{", 0);
                newLine = 1;
                indent ++;
                if (generateSubtree(opr->op[0])) return 1;
                print_append("for (", 1);
                print_append(";", 0);
                if (generateSubtree(opr->op[1])) return 1;
                print_append(";", 0);
                if (opr->numOperands == 4 && generateSubtree(opr->op[2])) return 1;
                print_append(")", 1);
                if (opr->op[opr->numOperands-1]->type == OPERATOR_NODE && opr->op[opr->numOperands-1]->opr.opType != comp_state) {
                    print_append("{", 1);
                    newLine = 1;
                    indent ++;
                    if (generateSubtree(opr->op[opr->numOperands-1])) return 1;
                    indent --;
                    print_append("}", 0);
                    newLine = 1;
                } else {
                    if (generateSubtree(opr->op[opr->numOperands-1])) return 1;
                }
                indent --;
                print_append("}", 0);
                newLine = 1;
            } else {
                print_append("for (", 1);
                if (generateSubtree(opr->op[0])) return 1;
                print_append(";", 0);
                if (generateSubtree(opr->op[1])) return 1;
                print_append(";", 0);
                if (opr->numOperands == 4 && generateSubtree(opr->op[2])) return 1;
                print_append(")", 1);
                if (opr->op[opr->numOperands-1]->type == OPERATOR_NODE && opr->op[opr->numOperands-1]->opr.opType != comp_state) {
                    print_append("{", 1);
                    newLine = 1;
                    indent ++;
                    if (generateSubtree(opr->op[opr->numOperands-1])) return 1;
                    indent --;
                    print_append("}", 0);
                    newLine = 1;
                } else {
                    if (generateSubtree(opr->op[opr->numOperands-1])) return 1;
                }
            }
            break;
        case jump_continue_state:
            print_append("continue;", 1);
            newLine = 1;
            break;
        case jump_break_state:
            print_append("break;", 1);
            newLine = 1;
            break;
        case jump_ret_state:
            if (mainFun) {
                print_append("__avl__loop.join();", 1);
                newLine = 1;
                print_append("delete __avl__vi;", 1);
                newLine = 1;
            } else {
                for (i=0; i<paraCount; i++) {
                    print_append(paraList[i], 0);
                    print_append(".lowlight();", 0);
                    newLine = 1;
                }
                print_append("__avl__vi->restore();", 1);
                newLine = 1;
            }
            print_append("return", 1);
            if (opr->numOperands == 1 && generateSubtree(opr->op[0])) return 1;
            print_append(";", 0);
            newLine = 1;
            break;
        case trans_unit:
            if (generateSubtree(opr->op[0])) return 1;
            if (generateSubtree(opr->op[1])) return 1;
            break;
        case func_def:
            needSleep = 0;
            if (strcmp(opr->op[1]->id.value,"main") == 0)
                mainFun = 1;
            else
                mainFun = 0;
            if (mainFun) {
                if (opr->op[0]->varType.value == INT_TYPE) print_append("int", 0);
                else print_append("void", 0);
            } else {
                if (generateSubtree(opr->op[0])) return 1;
            }
            if (generateSubtree(opr->op[1])) return 1;
            print_append("(", 0);
            if (paraList) free(paraList);
            paraCount = 0;
            if (mainFun) {
                print_append("int argc, char *argv[]",0);
            } else if (opr->numOperands == 4) {
                paraList = (char**)malloc(sizeof(char*)*numPara(&opr->op[2]->opr));
                if (generateSubtree(opr->op[2])) return 1;
            }
            print_append(")", 1);
            newLine = 1;
            print_append("{",0);
            newLine = 1;
            indent ++;
            if (mainFun) {
                print_line("\tstd::thread __avl__loop(__avl__display, argc, argv);");
                print_line("\t__avl__mtx.lock();");
                print_line("\t__avl__cv.wait(__avl__mtx, __avl__ready);");
                print_line("\t__avl__mtx.unlock();");
                print_line("\tavlSleep(0.5);");
            } else {
                print_line("\t__avl__vi->reset();");
                for (i=0; i<paraCount; i++) {
                    print_append(paraList[i], 0);
                    print_append(".lowlight();", 0);
                    newLine = 1;
                    print_append(paraList[i], 0);
                    print_append(".highlight();", 0);
                    newLine = 1;
                }
            }       
            if (generateSubtree(opr->op[opr->numOperands-1])) return 1;
            if (opr->op[0]->varType.value == VOID_TYPE) {
                if (mainFun) {
                    print_line("\t__avl__loop.join();");
                    print_line("\tdelete __avl__vi;");
                } else {
                    for (i=0; i<paraCount; i++) {
                        print_append(paraList[i], 0);
                        print_append(".lowlight();", 0);
                        newLine = 1;
                    }
                    print_line("\t__avl__vi->restore();");
                }
            }
            indent --;
            newLine = 1;
            print_append("}",0);
            break;
        case para_declar:
            // whether is an array
            temp = opr->op[1];
            while (temp->type == OPERATOR_NODE) {
                if (temp->opr.opType == arr_decl) break;
                temp = temp->opr.op[0];
            }
            if (temp->opr.opType == arr_decl) { // is array
                print_append("AvlArray<", 1);
                if (generateSubtree(opr->op[0])) return 1;
                print_append(">", 0);
                if (generateSubtree(temp->opr.op[0])) return 1;
                paraList[paraCount] = temp->opr.op[0]->id.value;
                paraCount ++;
            } else { // not array
                if (generateSubtree(opr->op[0])) return 1;
                if (generateSubtree(temp)) return 1;
            }
            break;
    }
    return 0;
}

void print_append(char* s, int space) {
    if (newLine) {
        fprintf(yyout, "\n");
        print_indent();
        newLine = 0;
        fprintf(yyout, "%s", s);
    } else {
        if (space)
            fprintf(yyout, " ");
        fprintf(yyout, "%s", s);
    }
}

void print_append_int(int value, int space) {
    if (newLine) {
        fprintf(yyout, "\n");
        print_indent();
        newLine = 0;
        fprintf(yyout, "%d", value);
    } else {
        if (space)
            fprintf(yyout, " ");
        fprintf(yyout, "%d", value);
    }
}

void print_indent() {
    int i;
    for (i=0; i<indent; i++) {
        fprintf(yyout, "\t");
    }
}

void print_header() {
    print_line("#include <AvlVisualizer.h>");
    print_line("#include <AvlTypes.h>");
    print_line("#include <condition_variable>");
    print_line("#include <cstdlib>");
    print_line("");

    print_line("AvlVisualizer *__avl__vi = NULL;");
    print_line("bool __avl__ready() { return __avl__vi != NULL; }");
    print_line("std::mutex __avl__mtx;");
    print_line("std::condition_variable_any __avl__cv;");
    print_line("");

    print_line("void __avl__display(int argc, char **argv)");
    print_line("{");
    print_line("\t__avl__mtx.lock();");
    print_line("\t__avl__vi = new AvlVisualizer(argc, argv);");
    print_line("\t__avl__cv.notify_one();");
    print_line("\t__avl__mtx.unlock();");
    print_line("");
    print_line("\t__avl__vi->show();");
    print_line("}");
    print_line("");
}

void print_line(const char *line) {
    fprintf(yyout, "%s\n", line);
}

void freeTree(nodeType* node) {
    int i;
    switch (node->type) {
        case CHARCON_NODE:
            free(node->charCon.value);
            break;
        case STRLIT_NODE:
            free(node->strLit.value);
            break;
        case ID_NODE:
            free(node->id.value);
            break;
        case MATHOP_NODE:
            free(node->mathOp.value);
            break;
        case OPERATOR_NODE:
            for (i=0; i<node->opr.numOperands; i++) {
                freeTree(node->opr.op[i]);
            }
            free(node->opr.op);
            break;
        default:
            break;
    }
    free(node);
}



file: avl/src/Makefile.am

BUILT_SOURCES = parser.h
AM_YFLAGS = -d
bin_PROGRAMS = avl
avl_SOURCES = scanner.l parser.y avl.c syntax_tree.c code_generator.c sym_list.c sym_table.c st_list.c type_check.c
AM_CFLAGS = -Werror



file: avl/src/parser.y

%{
#include "syntax_tree.h"

int yylex();
void yyerror(const char *format, ...);
%}

%debug

%union {
    int intConVal;
    char* strLitVal;
    char* idVal;
    char* charLitVal;
    struct nodeTypeTag* nt;
}

%token <idVal> IDENTIFIER 
%token LEN
%token <intConVal> CONSTANT 
%token <strLitVal> STRING_LITERAL 
%token <charLitVal> CHAR_LITERAL

%token INC_OP DEC_OP LE_OP GE_OP EQ_OP NE_OP
%token AND_OP OR_OP

%token PRINT SWAP 

%token CHAR INT VOID BOOL INDEX STRING
%token DISPLAY HIDE

%token IF ELSE WHILE DO FOR CONTINUE BREAK RETURN END_DISPLAY BEGIN_DISPLAY TRUE FALSE

%start program

%%

primary_expression
    : IDENTIFIER                        { $<nt>$ = idNodeCreator($<idVal>1); }
    | CONSTANT                          { $<nt>$ = intConNodeCreator($<intConVal>1); }
    | TRUE                              { $<nt>$ = boolConNodeCreator(1); }
    | FALSE                             { $<nt>$ = boolConNodeCreator(0); }
    | CHAR_LITERAL                      { $<nt>$ = charConNodeCreator($<charLitVal>1); }
    | STRING_LITERAL                    { $<nt>$ = strLitNodeCreator($<strLitVal>1); }
    | '(' conditional_expression ')'    { $<nt>$ = operatorNodeCreator(parentheses_exp, 1, $<nt>2); }
    ;

postfix_expression
    : primary_expression                                                    { $<nt>$ = $<nt>1; }
    | IDENTIFIER '[' conditional_expression ']'                             { $<nt>$ = operatorNodeCreator(array, 2, idNodeCreator($<idVal>1), $<nt>3); }
    | IDENTIFIER '[' conditional_expression ':' conditional_expression ']'  { $<nt>$ = operatorNodeCreator(array, 3, idNodeCreator($<idVal>1), $<nt>3, $<nt>5); }
    | IDENTIFIER '(' ')'                                                    { $<nt>$ = operatorNodeCreator(func_call, 1, idNodeCreator($<idVal>1)); }
    | IDENTIFIER '(' argument_expression_list ')'                           { $<nt>$ = operatorNodeCreator(func_call, 2, idNodeCreator($<idVal>1), $<nt>3); }   
    | postfix_expression INC_OP                                             { $<nt>$ = operatorNodeCreator(math_op, 2, $<nt>1, mathOpNodeCreator("++")); }
    | postfix_expression DEC_OP                                             { $<nt>$ = operatorNodeCreator(math_op, 2, $<nt>1, mathOpNodeCreator("--")); }
    ;

argument_expression_list
    : conditional_expression                                { $<nt>$ = $<nt>1; }
    | argument_expression_list ',' conditional_expression   { $<nt>$ = operatorNodeCreator(concatenate, 2, $<nt>1, $<nt>3); }
    ;

unary_expression
    : postfix_expression                { $<nt>$ = $<nt>1;}
    | INC_OP unary_expression           { $<nt>$ = operatorNodeCreator(math_op, 2, mathOpNodeCreator("++"), $<nt>2); }
    | DEC_OP unary_expression           { $<nt>$ = operatorNodeCreator(math_op, 2, mathOpNodeCreator("--"), $<nt>2); }
    | unary_operator unary_expression    { $<nt>$ = operatorNodeCreator(math_op, 2, $<nt>1, $<nt>2); }
    | LEN '(' unary_expression ')'      { $<nt>$ = operatorNodeCreator(len, 1, $<nt>3); }
    ;

unary_operator
    : '+'       { $<nt>$ = mathOpNodeCreator("+"); }
    | '-'       { $<nt>$ = mathOpNodeCreator("-"); }
    | '!'       { $<nt>$ = mathOpNodeCreator("!"); }
    ;

multiplicative_expression
    : unary_expression                               { $<nt>$ = $<nt>1; }
    | multiplicative_expression '*' unary_expression { $<nt>$ = operatorNodeCreator(math_op, 3, $<nt>1, mathOpNodeCreator("*"), $<nt>3); }
    | multiplicative_expression '/' unary_expression { $<nt>$ = operatorNodeCreator(math_op, 3, $<nt>1, mathOpNodeCreator("/"), $<nt>3); }
    | multiplicative_expression '%' unary_expression { $<nt>$ = operatorNodeCreator(math_op, 3, $<nt>1, mathOpNodeCreator("%"), $<nt>3); }
    ;

additive_expression
    : multiplicative_expression                         { $<nt>$ = $<nt>1; }
    | additive_expression '+' multiplicative_expression { $<nt>$ = operatorNodeCreator(math_op, 3, $<nt>1, mathOpNodeCreator("+"), $<nt>3); }
    | additive_expression '-' multiplicative_expression { $<nt>$ = operatorNodeCreator(math_op, 3, $<nt>1, mathOpNodeCreator("-"), $<nt>3); }
    ;

relational_expression
    : additive_expression                               { $<nt>$ = $<nt>1; }
    | relational_expression '<' additive_expression     { $<nt>$ = operatorNodeCreator(math_op, 3, $<nt>1, mathOpNodeCreator("<"), $<nt>3); }
    | relational_expression '>' additive_expression     { $<nt>$ = operatorNodeCreator(math_op, 3, $<nt>1, mathOpNodeCreator(">"), $<nt>3); }
    | relational_expression LE_OP additive_expression   { $<nt>$ = operatorNodeCreator(math_op, 3, $<nt>1, mathOpNodeCreator("<="), $<nt>3); }
    | relational_expression GE_OP additive_expression   { $<nt>$ = operatorNodeCreator(math_op, 3, $<nt>1, mathOpNodeCreator(">="), $<nt>3); }
    ;

equality_expression
    : relational_expression                             { $<nt>$ = $<nt>1; }
    | equality_expression EQ_OP relational_expression   { $<nt>$ = operatorNodeCreator(math_op, 3, $<nt>1, mathOpNodeCreator("=="), $<nt>3); }
    | equality_expression NE_OP relational_expression   { $<nt>$ = operatorNodeCreator(math_op, 3, $<nt>1, mathOpNodeCreator("!="), $<nt>3); }
    ;

logical_and_expression
    : equality_expression                               { $<nt>$ = $<nt>1; }
    | logical_and_expression AND_OP equality_expression { $<nt>$ = operatorNodeCreator(math_op, 3, $<nt>1, mathOpNodeCreator("&&"), $<nt>3); }
    ;

logical_or_expression
    : logical_and_expression                                { $<nt>$ = $<nt>1; }
    | logical_or_expression OR_OP logical_and_expression    { $<nt>$ = operatorNodeCreator(math_op, 3, $<nt>1, mathOpNodeCreator("||"), $<nt>3); }
    ;

conditional_expression
    : logical_or_expression                                                         { $<nt>$ = $<nt>1; }
    | logical_or_expression '?' conditional_expression ':' conditional_expression   { $<nt>$ = operatorNodeCreator(math_op, 3, $<nt>1, mathOpNodeCreator("?"), $<nt>3, mathOpNodeCreator(":"), $<nt>5); }
    ;

assignment_expression
    : postfix_expression '=' conditional_expression     { $<nt>$ = operatorNodeCreator(assignment, 2, $<nt>1, $<nt>3); }
    ;

type_specifier
    : VOID                      { $<nt>$ = varTypeNodeCreator(VOID_TYPE); }
    | CHAR                      { $<nt>$ = varTypeNodeCreator(CHAR_TYPE); }
    | INT                       { $<nt>$ = varTypeNodeCreator(INT_TYPE); }
    | STRING                    { $<nt>$ = varTypeNodeCreator(STRING_TYPE); }
    | INDEX                     { $<nt>$ = varTypeNodeCreator(INDEX_TYPE); }
    | BOOL                      { $<nt>$ = varTypeNodeCreator(BOOL_TYPE); }
    ;

expression
    : conditional_expression                                                        { $<nt>$ = $<nt>1; }
    | assignment_expression                                                         { $<nt>$ = $<nt>1; }
    | DISPLAY IDENTIFIER                                                            { $<nt>$ = operatorNodeCreator(disp_exp, 1, idNodeCreator($<idVal>2)); }
    | HIDE IDENTIFIER                                                               { $<nt>$ = operatorNodeCreator(hide_exp, 1, idNodeCreator($<idVal>2)); }
    | SWAP '(' IDENTIFIER ',' conditional_expression ',' conditional_expression ')' { $<nt>$ = operatorNodeCreator(swap, 3, idNodeCreator($<idVal>3), $<nt>5, $<nt>7); }
    | PRINT print_list                                                              { $<nt>$ = operatorNodeCreator(print, 1, $<nt>2); }
    ;

print_list
    : conditional_expression                        { $<nt>$ = $<nt>1; }
    | print_list ',' conditional_expression         { $<nt>$ = operatorNodeCreator(print_list, 2, $<nt>1, $<nt>3); }
    ;

declaration
    : type_specifier init_declarator                { $<nt>$ = operatorNodeCreator(var_decl, 2, $<nt>1, $<nt>2);  } 
    | DISPLAY type_specifier init_declarator        { $<nt>$ = operatorNodeCreator(var_decl_disp, 2, $<nt>2, $<nt>3);  }
    | HIDE type_specifier init_declarator           { $<nt>$ = operatorNodeCreator(var_decl_hide, 2, $<nt>2, $<nt>3);  }
    ;

init_declarator
    : declarator                                    { $<nt>$ = $<nt>1; }
    | declarator '=' initializer                    { $<nt>$ = operatorNodeCreator(assignment, 2, $<nt>1, $<nt>3); }
    ;

declarator
    : IDENTIFIER                                    { $<nt>$ = idNodeCreator($<idVal>1); }
    | IDENTIFIER '[' conditional_expression ']'     { $<nt>$ = operatorNodeCreator(arr_decl, 2, idNodeCreator($<idVal>1), $<nt>3); }
    | IDENTIFIER '[' ']'                            { $<nt>$ = operatorNodeCreator(arr_decl, 1, idNodeCreator($<idVal>1)); }
    ;

initializer
    : conditional_expression                        { $<nt>$ = $<nt>1; }
    | '{' initializer_list '}'                      { $<nt>$ = operatorNodeCreator(init_list, 1, $<nt>2); }
    ;

initializer_list
    : conditional_expression                        { $<nt>$ = $<nt>1; }
    | initializer_list ',' conditional_expression   { $<nt>$ = operatorNodeCreator(concatenate, 2, $<nt>1, $<nt>3); }
    ;

statement
    : compound_statement                            { $<nt>$ = $<nt>1; }
    | expression_statement                          { $<nt>$ = $<nt>1; }
    | declaration_statement                         { $<nt>$ = $<nt>1; }
    | display_statement                             { $<nt>$ = $<nt>1; }
    | selection_statement                           { $<nt>$ = $<nt>1; }
    | iteration_statement                           { $<nt>$ = $<nt>1; }
    | jump_statement                                { $<nt>$ = $<nt>1; }
    | ';'                                           { $<nt>$ = operatorNodeCreator(empty_state, 0); }
    ;

expression_statement
    : expression ';'                                { $<nt>$ = operatorNodeCreator(exp_state, 1, $<nt>1); }
    ;

declaration_statement
    : declaration ';'                               { $<nt>$ = operatorNodeCreator(declar_state, 1, $<nt>1); }
    ;

compound_statement 
    : '{' '}'                                       { $<nt>$ = operatorNodeCreator(comp_state, 0); }
    | '{' statement_list '}'                        { $<nt>$ = operatorNodeCreator(comp_state, 1, $<nt>2); }
    ;

statement_list
    : statement                                     { $<nt>$ = $<nt>1; }
    | statement_list statement                      { $<nt>$ = operatorNodeCreator(state_list, 2, $<nt>1, $<nt>2); }
    ;

display_statement
    : BEGIN_DISPLAY statement_list END_DISPLAY      { $<nt>$ = operatorNodeCreator(display_state, 1, $<nt>2); }
    ;

selection_statement
    : IF '(' conditional_expression ')' statement                   { $<nt>$ = operatorNodeCreator(select_state, 2, $<nt>3, $<nt>5); }
    | IF '(' conditional_expression ')' statement ELSE statement    { $<nt>$ = operatorNodeCreator(select_state, 3, $<nt>3, $<nt>5, $<nt>7); }
    ;

iteration_statement
    : WHILE '(' conditional_expression ')' statement                                { $<nt>$ = operatorNodeCreator(while_state, 2, $<nt>3, $<nt>5); }
    | DO statement WHILE '(' conditional_expression ')' ';'                         { $<nt>$ = operatorNodeCreator(do_while_state, 2, $<nt>2, $<nt>5); }
    | FOR '(' expression ';' conditional_expression ';' ')' statement               { $<nt>$ = operatorNodeCreator(for_state, 3, $<nt>3, $<nt>5, $<nt>8); }
    | FOR '(' expression ';' conditional_expression ';' expression ')' statement    { $<nt>$ = operatorNodeCreator(for_state, 4, $<nt>3, $<nt>5, $<nt>7, $<nt>9); }
    | FOR '(' declaration ';' conditional_expression ';' ')' statement              { $<nt>$ = operatorNodeCreator(for_state, 3, $<nt>3, $<nt>5, $<nt>8); }
    | FOR '(' declaration ';' conditional_expression ';' expression ')' statement   { $<nt>$ = operatorNodeCreator(for_state, 4, $<nt>3, $<nt>5, $<nt>7, $<nt>9); }
    ;

jump_statement
    : CONTINUE ';'                                  { $<nt>$ = operatorNodeCreator(jump_continue_state, 0); }
    | BREAK ';'                                     { $<nt>$ = operatorNodeCreator(jump_break_state, 0); }
    | RETURN ';'                                    { $<nt>$ = operatorNodeCreator(jump_ret_state, 0); }
    | RETURN conditional_expression ';'             { $<nt>$ = operatorNodeCreator(jump_ret_state, 1, $<nt>2); }
    ;

translation_unit
    : function_definition                   { $<nt>$ = $<nt>1; }
    | translation_unit function_definition  { $<nt>$ = operatorNodeCreator(trans_unit, 2, $<nt>1, $<nt>2); }
    ;

function_definition
    : type_specifier  IDENTIFIER '(' parameter_list ')' compound_statement  { $<nt>$ = operatorNodeCreator(func_def, 4, $<nt>1, idNodeCreator($<idVal>2), $<nt>4, $<nt>6); }
    | type_specifier  IDENTIFIER '('  ')' compound_statement                { $<nt>$ = operatorNodeCreator(func_def, 3, $<nt>1, idNodeCreator($<idVal>2), $<nt>5); }
    ;

parameter_list
    : parameter_declaration                     { $<nt>$ = $<nt>1; }
    | parameter_list ',' parameter_declaration  { $<nt>$ = operatorNodeCreator(concatenate, 2, $<nt>1, $<nt>3); }
    ;

parameter_declaration
    : type_specifier declarator                 { $<nt>$ = operatorNodeCreator(para_declar, 2, $<nt>1, $<nt>2); }
    ;

program
    : translation_unit                          { int ret = typeChecking($<nt>1); if (!ret) avl_code_generator($<nt>1); }
    ;
    
%%





file: avl/src/scanner.l

%{
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <stdarg.h>
#include "parser.h"

void yyerror(const char *format, ...);
%}

%option debug warn verbose

D                   [0-9]
L                   [A-Za-z_]
C                   [A-Za-z0-9,.?!:; ]

%x COMMENT

%%

"/*"                { BEGIN(COMMENT); }
<COMMENT>"*/"       { BEGIN(INITIAL); }
<COMMENT>.          { /* disregard all characters in comments. */ }

true                { return TRUE; }
false               { return FALSE; }
break               { return BREAK; }
char                { return CHAR; }
string              { return STRING; }
continue            { return CONTINUE; }
do                  { return DO; }
else                { return ELSE; }
for                 { return FOR; }
if                  { return IF; }
int                 { return INT; }
index               { return INDEX; }
return              { return RETURN; }
len                 { return LEN; }
void                { return VOID; }
while               { return WHILE; }
swap                { return SWAP; }
print               { return PRINT; }
bool                { return BOOL; }
display             { return DISPLAY; }
hide                { return HIDE; }
\<begin_display\>   { return BEGIN_DISPLAY; }
\<end_display\>     { return END_DISPLAY; }

{L}({L}|{D})*       { /* identifier */
                        yylval.idVal = strdup(yytext);
                        return IDENTIFIER;
                    }

{D}+                { /* integer */
                        yylval.intConVal = atoi(yytext);
                        return CONSTANT;
                    }

'{C}'               { /* single character, escape characters are not allowed */
                        yylval.strLitVal = strdup(yytext);
                        return CHAR_LITERAL;
                    }

\"{C}*\"            { /* string literal, escape characters are not allowed */
                        yylval.strLitVal = strdup(yytext);
                        return STRING_LITERAL;
                    }

"++"                { return INC_OP; }
"--"                { return DEC_OP; }
"&&"                { return AND_OP; }
"||"                { return OR_OP; }
"<="                { return LE_OP; }
">="                { return GE_OP; }
"=="                { return EQ_OP; }
"!="                { return NE_OP; }
";"                 { return ';'; }
"{"                 { return '{'; }
"}"                 { return '}'; }
","                 { return ','; }
":"                 { return ':'; }
"="                 { return '='; }
"("                 { return '('; }
")"                 { return ')'; }
"["                 { return '['; }
"]"                 { return ']'; }
"!"                 { return '!'; }
"-"                 { return '-'; }
"+"                 { return '+'; }
"*"                 { return '*'; }
"/"                 { return '/'; }
"%"                 { return '%'; }
"<"                 { return '<'; }
">"                 { return '>'; }
"?"                 { return '?'; }

[ \t\n]             { /* disregard white spaces */ }
.                   { yyerror("bad character found: %s", yytext); }

%%

int yywrap()
{
    return 1;
}

void yyerror(const char *format, ...)
{
    va_list ap;

    va_start(ap, format);
    vfprintf(stderr, format, ap);
    fprintf(stderr, "\n");
    va_end(ap);
}



file: avl/src/st_list.c

#include <stdlib.h>
#include <string.h>
#include "st_list.h"

void st_list_init(struct st_list *sl)
{
    sl->first = NULL;
    sl->last = NULL;
}

void st_list_destroy(struct st_list *sl)
{
    while (sl->first)
    {
        struct st_node *node = sl->first->next;
        free(sl->first);
        sl->first = node;
    }

    sl->last = NULL;
}

void st_list_add(struct st_list *sl, struct sym_table *st)
{
    struct st_node *node = (struct st_node *)malloc(sizeof(struct st_node));
    memset(node, 0, sizeof(struct st_node));
    node->st = st;

    if (!sl->first)
    {
        sl->first = node;
        sl->last = node;
    }
    else
    {
        node->next = sl->first;
        sl->first->prev = node;
        sl->first = node;
    }
}

void st_list_add_tail(struct st_list *sl, struct sym_table *st)
{
    struct st_node *node = (struct st_node *)malloc(sizeof(struct st_node));
    memset(node, 0, sizeof(struct st_node));
    node->st = st;

    if (!sl->first)
    {
        sl->first = node;
        sl->last = node;
    }
    else
    {
        node->prev = sl->last;
        sl->last->next = node;
        sl->last = node;
    }
}

void st_list_del(struct st_list *sl)
{
    if (!sl->first)
        return;

    if (sl->first == sl->last)
    {
        free(sl->first);
        sl->first = NULL;
        sl->last = NULL;
        return;
    }

    struct st_node *node = sl->first->next;
    free(sl->first);
    node->prev = NULL;
    sl->first = node;
}

void st_list_del_tail(struct st_list *sl)
{
    if (!sl->last)
        return;

    if (sl->first == sl->last)
    {
        free(sl->last);
        sl->first = NULL;
        sl->last = NULL;
        return;
    }

    struct st_node *node = sl->last->prev;
    free(sl->last);
    node->next = NULL;
    sl->last = node;
}

struct sym_table *st_list_head(const struct st_list *sl)
{
    return sl->first->st;
}

struct sym_table *st_list_tail(const struct st_list *sl)
{
    return sl->last->st;
}

struct identifier *st_list_find(const struct st_list *st, const char *id)
{
    struct st_node *node = st->first;
    struct identifier *ret = NULL;

    while (node)
    {
        ret = sym_table_find(node->st, id);
        if (ret)
            return ret;

        node = node->next;
    }

    return ret;
}



file: avl/src/st_list.h

#ifndef ST_LIST_H_
#define ST_LIST_H_

#include "sym_table.h"

struct st_node
{
    struct sym_table *st;
    struct st_node *prev;
    struct st_node *next;
};

struct st_list
{
    struct st_node *first;
    struct st_node *last;
};

/* initialize a list for symbol tables */
void st_list_init(struct st_list *sl);

/* destroy a list for symbol tables */
void st_list_destroy(struct st_list *sl);

/* add a symbol table to the head of a list */
void st_list_add(struct st_list *sl, struct sym_table *st);

/* add a symbol table to the end of a list */
void st_list_add_tail(struct st_list *sl, struct sym_table *st);

/* delete a symbol table from the head of a list */
void st_list_del(struct st_list *sl);

/* delete a symbol table from the end of a list */
void st_list_del_tail(struct st_list *sl);

/* return the head of a list */
struct sym_table *st_list_head(const struct st_list *sl);

/* return the end of a list */
struct sym_table *st_list_tail(const struct st_list *sl);

/* search for an identifier in a list,
 * return a pointer if the id is found,
 * return NULL otherwise*/
struct identifier *
st_list_find(const struct st_list *st, const char *id);

#endif /* ST_LIST_H_ */



file: avl/src/sym_list.c

#include <string.h>
#include <stdlib.h>
#include "sym_list.h"

void sym_list_init(struct sym_list *sl)
{
    sl->first = NULL;
    sl->last = NULL;
}

void sym_list_destroy(struct sym_list *sl)
{
    while (sl->first)
    {
        struct identifier_node *node = sl->first->next;
        free(sl->first);
        sl->first = node;
    }

    sl->last = NULL;
}

void sym_list_add(struct sym_list *sl, const struct identifier *id)
{
    if (sym_list_find(sl, id->name) != NULL)
        return;

    struct identifier_node *node = (struct identifier_node *)malloc(sizeof(struct identifier_node));
    memset(node, 0, sizeof(struct identifier_node));
    memcpy(&node->id, id, sizeof(struct identifier));

    if (!sl->first)
    {
        sl->first = node;
        sl->last = node;
    }
    else
    {
        node->next = sl->first;
        sl->first->prev = node;
        sl->first = node;
    }
}

void sym_list_add_tail(struct sym_list *sl, const struct identifier *id)
{
    if (sym_list_find(sl, id->name) != NULL)
        return;

    struct identifier_node *node = (struct identifier_node *)malloc(sizeof(struct identifier_node));
    memset(node, 0, sizeof(struct identifier_node));
    memcpy(&node->id, id, sizeof(struct identifier));

    if (!sl->first)
    {
        sl->first = node;
        sl->last = node;
    }
    else
    {
        node->prev = sl->last;
        sl->last->next = node;
        sl->last = node;
    }
}

void sym_list_del(struct sym_list *sl, const char *id)
{
    if (sym_list_find(sl, id) == NULL)
        return;

    if (sl->first == sl->last)
    {
        free(sl->first);
        sl->first = NULL;
        sl->last = NULL;
        return;
    }

    struct identifier_node *node = sl->first;
    
    while (node)
    {
        if (strcmp(node->id.name, id) == 0)
        {
            if (node == sl->first)
            {
                node->next->prev = NULL;
                sl->first = node->next;
            }
            else if (node == sl->last)
            {
                node->prev->next = NULL;
                sl->last = node->prev;
            }
            else
            {
                node->prev->next = node->next;
                node->next->prev = node->prev;
            }
            free(node);
            return;
        }
        else
            node = node->next;
    }
}

struct identifier *sym_list_find(const struct sym_list *sl, const char *id)
{
    struct identifier_node *node = sl->first;

    while (node)
    {
        if (strcmp(node->id.name, id) == 0)
            return &node->id;

        node = node->next;
    }

    return NULL;
}



file: avl/src/sym_list.h

#ifndef SYM_LIST_H_
#define SYM_LIST_H_

#include "syntax_tree.h"

/* the max length of any identifier is SYM_LEN - 1 */
//#define SYM_LEN 32

struct identifier
{
    char* name;
    /* more attributes to be added */
    varTypeEnum type;
    int isArray;
    int isFunc;
    int numArgs;
    varTypeEnum* args;
    int* argsIsArray;
};

struct identifier_node
{
    struct identifier id;
    struct identifier_node *prev;
    struct identifier_node *next;
};

struct sym_list
{
    struct identifier_node *first;
    struct identifier_node *last;
};

/* initialize a symbol list */
void sym_list_init(struct sym_list *sl);

/* destroy a symbol list */
void sym_list_destroy(struct sym_list *sl);

/* add an identifier to the head of a list */
void sym_list_add(struct sym_list *sl, const struct identifier *id);

/* add an identifier to the tail of a list */
void sym_list_add_tail(struct sym_list *sl, const struct identifier *id);

/* delete an identifier */
void sym_list_del(struct sym_list *sl, const char *id);

/* search for an identifier in a list,
 * return a pointer if the id is found,
 * return NULL otherwise */
struct identifier *
sym_list_find(const struct sym_list *sl, const char *id);

#endif /* SYM_LIST_H_ */



file: avl/src/sym_table.c

#include <string.h>
#include "sym_table.h"

size_t hash(const char *id)
{
    size_t num = 0;
    size_t len = strlen(id);
    size_t i;

    for (i = 0; i < len; i++)
    {
        num *= 64;
        num %= SYM_TABLE_SIZE;

        if (id[i] == '_')
            num += 0;
        else if ('a' <= id[i] && id[i] <= 'z')
            num += (unsigned int)(id[i] - 'a' + 1);
        else if ('A' <= id[i] && id[i] <= 'Z')
            num += (unsigned int)(id[i] - 'A' + 27);
        else /* '0' <= id[i] && id[i] <= '9' */
            num += (unsigned int)(id[i] - '0' + 53);
    }

    return num % SYM_TABLE_SIZE;
}

void sym_table_init(struct sym_table *st)
{
    size_t i;

    for (i = 0; i < SYM_TABLE_SIZE; i++)
        sym_list_init(&st->htable[i]);
}

void sym_table_destroy(struct sym_table *st)
{
    size_t i;

    for (i = 0; i < SYM_TABLE_SIZE; i++)
        sym_list_destroy(&st->htable[i]);
}

void sym_table_add(struct sym_table *st, const struct identifier *id)
{
    size_t idx = hash(id->name);

    sym_list_add(&st->htable[idx], id);
}

void sym_table_del(struct sym_table *st, const char *id)
{
    size_t idx = hash(id);

    sym_list_del(&st->htable[idx], id);
}

struct identifier *sym_table_find(const struct sym_table *st, const char *id)
{
    size_t idx = hash(id);

    return sym_list_find(&st->htable[idx], id);
}



file: avl/src/sym_table.h

#ifndef SYM_TABLE_H_
#define SYM_TABLE_H_

#include "sym_list.h"

#define SYM_TABLE_SIZE 701

struct sym_table
{
    struct sym_list htable[SYM_TABLE_SIZE];
};

/* initialize a symbol table */
void sym_table_init(struct sym_table *st);

/* destroy a symbol table */
void sym_table_destroy(struct sym_table *st);

/* add an identifier to a symbol table */
void sym_table_add(struct sym_table *st, const struct identifier *id);

/* delete an identifier */
void sym_table_del(struct sym_table *st, const char *id);

/* search for an identifier in a symbol table,
 * return a pointer if the id is found,
 * return NULL otherwise */
struct identifier *sym_table_find(const struct sym_table *st, const char *id);

#endif /* SYM_TABLE_H_ */



file: avl/src/syntax_tree.c

#include <stdlib.h>
#include <stdio.h>
#include <stdarg.h>
#include <string.h>
#include "syntax_tree.h"

///////////////////////////////////////////////////////////////

nodeType* intConNodeCreator (int value) {
    nodeType *p;

    // allocating memory
    if ((p = (nodeType*)malloc(sizeof(nodeType))) == NULL)
        printf("out of memory\n");

    p->type = INTCON_NODE;
    p->intCon.value = value;

    return p;
}

///////////////////////////////////////////////////////////////

nodeType* charConNodeCreator (char* value) {
    nodeType *p;

    // allocating memory
    if ((p = (nodeType*)malloc(sizeof(nodeType))) == NULL)
        printf("out of memory\n");

    p->type = CHARCON_NODE;
    p->charCon.value = value;

    return p;
}

nodeType* boolConNodeCreator (int value) {
    nodeType *p;

    // allocating memory
    if ((p = (nodeType*)malloc(sizeof(nodeType))) == NULL)
        printf("out of memory\n");

    p->type = BOOLCON_NODE;
    p->boolCon.value = value;

    return p;
}
///////////////////////////////////////////////////////////////

nodeType* strLitNodeCreator (char* value) {
    nodeType* p;

    // allocating memory
    if ((p = (nodeType*)malloc(sizeof(nodeType))) == NULL)
        printf("out of memory\n");
    
    p->type = STRLIT_NODE;
    p->strLit.value = value;

    return p;
}

///////////////////////////////////////////////////////////////

nodeType* varTypeNodeCreator (varTypeEnum type) {
    nodeType* p;

    // allocating memory
    if ((p = (nodeType*)malloc(sizeof(nodeType))) == NULL)
        printf("out of memory\n");
    
    p->type = VARTYPE_NODE;
    p->varType.value = type;

    return p;
}

///////////////////////////////////////////////////////////////

nodeType* idNodeCreator (char* value) {
    nodeType* p;

    // allocating memory
    if ((p = (nodeType*)malloc(sizeof(nodeType))) == NULL)
        printf("out of memory\n");

    p->type = ID_NODE; 
    p->id.value = value;

    return p;
}

///////////////////////////////////////////////////////////////

nodeType* mathOpNodeCreator(char* value) {
    nodeType* p;

    // allocating memroy
    if ((p = (nodeType*)malloc(sizeof(nodeType))) == NULL)
        printf("out of memory\n");

    p->type = MATHOP_NODE; 
    p->mathOp.value = strdup(value);

    return p;
}

///////////////////////////////////////////////////////////////

nodeType* operatorNodeCreator (operatorTypeEnum oprtr, int numOperands, ...) {
    nodeType* p;
    va_list ap;

    // allocating memory
    if ((p = (nodeType*)malloc(sizeof(nodeType))) == NULL)
        printf("out of memory\n");
    
    if ((p->opr.op = (nodeType**)malloc(numOperands * sizeof(nodeType*))) == NULL)
        printf("out of memory\n");
    
    p->type = OPERATOR_NODE;
    p->opr.opType = oprtr;
    p->opr.numOperands = numOperands;

    va_start(ap, numOperands);
    int i;
    for (i = 0; i < numOperands; i ++) {
        p->opr.op[i] = va_arg(ap, nodeType*);
    }
    va_end(ap);

    return p;
}



file: avl/src/syntax_tree.h

#ifndef SYNTAX_TREE_H_
#define SYNTAX_TREE_H_

typedef enum {
    INTCON_NODE,
    BOOLCON_NODE,
    CHARCON_NODE,
    STRLIT_NODE,
    VARTYPE_NODE,
    ID_NODE,
    MATHOP_NODE,
    OPERATOR_NODE
} nodeTypeEnum;

typedef enum {
    parentheses_exp,
    array,
    func_call,
    concatenate,
    math_op,
    len,
    assignment,
    disp_exp,
    hide_exp,
    swap,
    print,
    print_list,
    var_decl,
    var_decl_disp,
    var_decl_hide,
    arr_decl,
    init_list,
    empty_state,
    exp_state,
    declar_state,
    comp_state,
    state_list,
    display_state,
    select_state,
    while_state,
    do_while_state,
    for_state,
    jump_continue_state,
    jump_break_state,
    jump_ret_state,
    trans_unit,
    func_def,
    para_declar
} operatorTypeEnum;

typedef enum {
    VOID_TYPE,
    CHAR_TYPE,
    INT_TYPE,
    STRING_TYPE,
    INDEX_TYPE,
    BOOL_TYPE
} varTypeEnum;

// integer constants
typedef struct {
    int value;
} intConNode;

//char constants
typedef struct {
    char* value;
} charConNode;

// bool constants
typedef struct {
    int value;
} boolConNode;

// string literal
typedef struct {
    char* value;
} strLitNode;

// type specifier
typedef struct {
    varTypeEnum value;
} varTypeNode;

// identifiers
typedef struct {
    char* value;
} idNode;

// math operator
typedef struct {
    char* value;
} mathOpNode;

// operators
typedef struct {
    operatorTypeEnum opType;
    int numOperands;
    struct nodeTypeTag **op;
} oprNode;


//////////////////////////////////////////////////////////

typedef struct nodeTypeTag {
    nodeTypeEnum type;

    union {
        intConNode intCon;
        charConNode charCon;
        boolConNode boolCon;
        strLitNode strLit;
        varTypeNode varType;
        idNode id;
        mathOpNode mathOp;
        oprNode opr;
        
    };

} nodeType;

///////////////////////////////////////////////////////////

nodeType* intConNodeCreator (int value);

nodeType* charConNodeCreator (char* value);

nodeType* boolConNodeCreator (int value);

nodeType* strLitNodeCreator (char* value);

nodeType* varTypeNodeCreator (varTypeEnum type);

nodeType* idNodeCreator (char* value);

nodeType* mathOpNodeCreator(char* value);

nodeType* operatorNodeCreator (operatorTypeEnum, int, ...);

void avl_code_generator(nodeType* root);

int typeChecking(nodeType* root);

void freeTree(nodeType* node);

#endif



file: avl/src/type_check.c

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "syntax_tree.h"
#include "st_list.h"
#include "sym_table.h"

void freeTree(nodeType* node);
int typeCheckingOpNode(oprNode* opr);
int typeCheckingSubTree(nodeType* node);

void getParaList(nodeType*);
void clearParaList();

char* idGen(nodeType* node);
varTypeEnum typeGen(nodeType* node);


extern FILE *yyout;
struct identifier** paraList;
size_t paraCount;
int mainFun;

struct st_list symbolTableStack;

int typeChecking(nodeType* root) {

    st_list_init(&symbolTableStack);
    
    paraList = NULL;
    paraCount = 0;
    int ret = typeCheckingSubTree(root);
    clearParaList();    

    if (ret == 0) {
        printf("Type checking succeeds.\n");
    } else {
        printf("Type checking fails.\n");
        freeTree(root);
    }
    return ret;
}



int typeCheckingSubTree(nodeType* node) {
    if (node->type == OPERATOR_NODE) {
        if(typeCheckingOpNode(&node->opr)) {
            return 1;
        }
    }
    return 0;
}

int typeCheckingOpNode(oprNode* opr) {
    int i;
    nodeType* temp = 0;
    char* idName = 0;
    struct identifier* id = 0;
    struct sym_table* newSymbolTable = 0;
    switch (opr->opType) {

        case parentheses_exp:
            temp = opr->op[0];
            /*
             * Now temp is a conditional-expression node. 
             *      It can be various operator node;
             *      It can be ID node;
             *      It can be const node;
             */
            if (temp->type == OPERATOR_NODE) {
                if (typeCheckingOpNode (&(temp->opr)))
                    return 1;
            }

            else if (temp->type == ID_NODE) {
                idName = idGen(opr->op[0]);
                id = sym_table_find(symbolTableStack.first->st, idName);
                if (!id) {
                    printf ("Identifier not found: %s\n", idName);
                    return 1;
                }
            }

            break;

        case array:
            // else if (opr->op[0]->type == ID_NODE) {
            idName = idGen(opr->op[0]);
            id = sym_table_find(symbolTableStack.first->st, idName);
            if (!id) { 
                printf ("Identifier not found: %s\n", idName);
                return 1;
            }

            // one index
            if (opr->numOperands == 2) { 
                temp = opr->op[1];
                /*
                 * Now temp is a conditional-expression node. 
                 *      It can be various operator node;
                 *      It can be ID node;
                 *      It can be const node;
                 */
                if (temp->type == OPERATOR_NODE) {
                    if (typeCheckingOpNode (&(temp->opr)))
                        return 1;
                }

                else if (temp->type == ID_NODE) {
                    idName = idGen(opr->op[0]);
                    id = sym_table_find(symbolTableStack.first->st, idName);
                    if (!id) {
                        printf ("Identifier not found: %s\n", idName);
                        return 1;
                    }
                }
            } 

            // two index, representing a range
            else {
                temp = opr->op[1];
                /*
                 * Now temp is a conditional-expression node. 
                 *      It can be various operator node;
                 *      It can be ID node;
                 *      It can be const node;
                 */
                if (temp->type == OPERATOR_NODE) {
                    if (typeCheckingOpNode (&(temp->opr)))
                        return 1;
                }

                else if (temp->type == ID_NODE) {
                    idName = idGen(opr->op[0]);
                    id = sym_table_find(symbolTableStack.first->st, idName);
                    if (!id) {
                        printf ("Identifier not found: %s\n", idName);
                        return 1;
                    }
                }

                temp = opr->op[2];
                /*
                 * Now temp is a conditional-expression node. 
                 *      It can be various operator node;
                 *      It can be ID node;
                 *      It can be const node;
                 */
                if (temp->type == OPERATOR_NODE) {
                    if (typeCheckingOpNode (&(temp->opr)))
                        return 1;
                }

                else if (temp->type == ID_NODE) {
                    idName = idGen(opr->op[0]);
                    id = sym_table_find(symbolTableStack.first->st, idName);
                    if (!id) {
                        printf ("Identifier not found: %s\n", idName);
                        return 1;
                    }
                }

            }

            break;

        case func_call:
            idName = idGen(opr->op[0]);

            // no symbol table loaded
            if (!symbolTableStack.first) {
                printf("Function not defined: %s\n.", idName);
                return 1;
            }

            // id not found
            id = sym_table_find(symbolTableStack.last->st, idName);
            if (!id) {
                printf("Function not defined: %s\n.", idName);
                return 1;
            }

            if (!id->isFunc) {
                printf("%s is not a function.", idName);
                return 1;
            }

            // there are arguments
            if (opr->numOperands == 2) {
                temp = opr->op[1]; // now temp is an argument expression list

                int numArguments = 1;
                while (temp->type == OPERATOR_NODE && temp->opr.opType == concatenate) {
                    numArguments += 1;
                    temp = temp->opr.op[0];
                }

                if (id->numArgs != numArguments) {
                    printf("Function arguments do not match: %s\n", idName);
                    return 1;
                }
            }

            break;

        case math_op:
            // iterate the node's operands (children)
            for (i=0; i < opr->numOperands; i++) {
                temp = opr->op[i];
                if (temp->type == MATHOP_NODE)
                    continue;

                if (temp->type == OPERATOR_NODE && temp->opr.opType == math_op) {
                    if (typeCheckingOpNode(&(temp->opr)))
                        return 1;
                }

                else if (temp->type == OPERATOR_NODE) {
                    printf("Math operation on illegal operands.\n");
                    return 1;
                }

                else if (temp->type == ID_NODE) {
                    idName = idGen(opr->op[i]);
                    id = sym_table_find(symbolTableStack.first->st, idName);
                    if (!id) {
                        printf("Identifier not found: %s\n", idName);
                        return 1;
                    }
                    
                    if (id->type != INT_TYPE && id->type != INDEX_TYPE && id->type != BOOL_TYPE) {
                        printf("Math operation can only be applied to int, index or bool type: %s\n", idName);
                        return 1;
                    }
                }

                else if (opr->op[i]->type != INTCON_NODE || opr->op[i]->type != BOOLCON_NODE ) {
                    printf("Math operation can only be applied to int, index or bool type.\n");
                    return 1;
                }
            }
            break;

        case len:
            if (opr->op[0]->type != ID_NODE) {
                printf ("len operator can only be applied to an array.\n");
                return 1;
            }

            else {
                idName = idGen(opr->op[0]);
                id = sym_table_find(symbolTableStack.first->st, idName);

                if (!id) {
                    printf("Identifier not found: %s\n", idName);
                    return 1;
                }

                if (! (id->isArray) ) {
                    printf ("len operator can only be applied to an array.\n");
                    return 1;
                }
            }

            break;

        case assignment:
            temp = opr->op[0];
            /*
             * Now temp could be postfix-expression or declarator. 
             * 1. If it is postfix-expression:
             *      It can be an identifier node;
             *      It can be an operator node with array operation
             *      It CANNOT be anything else, including const node, other kinds of operator nodes
             *
             * 2. If it is declarator:
             *      It can be an identifier node;
             *      It can be an operator node with arr_decl operation, but if so, the first operand is ID. 
             */

            // It is an operator node, with array operation
            if (temp->type == OPERATOR_NODE && temp->opr.opType == array) {
                if (typeCheckingOpNode(&(temp->opr))) 
                    return 1;
            }

            // It is an operator node, with arr_decl operation
            if (temp->type == OPERATOR_NODE && temp->opr.opType == arr_decl) {
                temp = temp->opr.op[0];
                idName = idGen(temp);
                id = sym_table_find(symbolTableStack.first->st, idName);
                if(!id) {
                    printf ("Identifier not found: %s\n", idName);
                    return 1;
                }
            }

            // It is an identifier node
            else if (temp->type == ID_NODE) {
                idName = idGen(temp);
                id = sym_table_find(symbolTableStack.first->st, idName);
                if(!id) {
                    printf ("Identifier not found: %s\n", idName);
                    return 1;
                }
            }

            else {
                printf("Illegal assignment.\n");
                return 1;
            }

            if (typeCheckingSubTree(opr->op[1])) return 1;
            break;

        case disp_exp:
            temp = opr->op[0];
            idName = idGen(temp);

            id = sym_table_find(symbolTableStack.first->st, idName);
            if(!id) {
                printf ("Identifier not found: %s\n", idName);
                return 1;
            }
            
            if (id->type == STRING_TYPE) {
                printf ("Cannot display string type: %s\n", idName);
                return 1;
            }

            break;

        case hide_exp:
            temp = opr->op[0];
            idName = idGen(temp);

            id = sym_table_find(symbolTableStack.first->st, idName);
            if(!id) {
                printf ("Identifier not found: %s\n", idName);
                return 1;
            }
            break;

        case swap:
            temp = opr->op[0];
            if (temp->type != ID_NODE) {
                printf("Swap can only be applied to an array.\n");
                return 1;
            }

            idName = idGen(temp);
            id = sym_table_find(symbolTableStack.first->st, idName);
            if (!id) {
                printf ("Identifier not found: %s\n", idName);
                return 1;
            }

            if (!id->isArray) {
                printf("Swap can only be applied to an array.\n");
                return 1;
            }

            // index one
            temp = opr->op[1];
            if (temp->type == OPERATOR_NODE) {
                if (temp->opr.opType != math_op) {
                    printf ("Illegal index.\n");
                    return 1;
                }
                if (typeCheckingOpNode(&temp->opr)) return 1;
            }
            else if (temp->type == ID_NODE) {
                idName = idGen(temp);
                id = sym_table_find(symbolTableStack.first->st, idName);
                if (!id) {
                    printf("Identifier not found: %s\n", idName);
                    return 1;
                }
                if (id->type != INT_TYPE && id->type != INDEX_TYPE) {
                    printf("Index can only be int type or index type: %s\n", idName);
                    return 1;
                }
            }

            else if (temp->type != INTCON_NODE) {
                printf ("Illegal index.\n");
                return 1;
            }

            // index two
            else if (temp->type != INTCON_NODE ) {
                printf("Index can only be int type or index type: %s\n", idName);
                return 1;
            }

            temp = opr->op[2];
            if (temp->type == OPERATOR_NODE) {
                if (temp->opr.opType != math_op) {
                    printf ("Illegal index.\n");
                    return 1;
                }
                if (typeCheckingOpNode(&temp->opr)) return 1;
            }

            else if (temp->type == ID_NODE) {
                idName = idGen(temp);
                id = sym_table_find(symbolTableStack.first->st, idName);
                if (!id) {
                    printf("Identifier not found: %s\n", idName);
                    return 1;
                }
                if (id->type != INT_TYPE && id->type != INDEX_TYPE) {
                    printf("Index can only be int or index: %s\n", idName);
                    return 1;
                }
            }

            else if (temp->type != INTCON_NODE) {
                printf ("Illegal index.\n");
                return 1;
            }

            break;

        case print:
            if (typeCheckingSubTree(opr->op[0])) return 1;
            break;

        case print_list:
            temp = opr->op[0];
            if (temp->type == OPERATOR_NODE && temp->opr.opType == print_list) {
                if (typeCheckingOpNode(&temp->opr))
                    return 1;
            }

            else if (temp->type == OPERATOR_NODE) {
                if (typeCheckingOpNode(&temp->opr))
                        return 1;
            }

            else if (temp->type == ID_NODE) {
                idName = idGen(temp);
                id = sym_table_find(symbolTableStack.first->st, idName);
                if(!id) {
                    printf ("Identifier not found: %s\n", idName);
                    return 1;
                }
            }

            temp = opr->op[2];
            idName = idGen(temp);
            id = sym_table_find(symbolTableStack.first->st, idName);
            if(!id) {
                printf ("Identifier not found: %s\n", idName);
                return 1;
            }

            break;

        case var_decl:
        case var_decl_disp:
        case var_decl_hide:

            // whether is an array
            temp = opr->op[1];
            while (temp->type == OPERATOR_NODE) {
                if (temp->opr.opType == arr_decl) break;
                temp = temp->opr.op[0];
            }

            if (temp->opr.opType == arr_decl) { // is array
                if (temp->opr.op[0]->type != ID_NODE) {
                    printf("Illegal array declaration!\n");
                    return 1;
                }
                idName = idGen(temp->opr.op[0]);
                id = sym_table_find(symbolTableStack.first->st, idName);
                if (id) {
                    printf("Redefinition of %s\n.", idName);
                    return 1;
                }

                id->name = idName;
                id->type = typeGen(opr->op[0]);
                id->isArray = 1;
                id->isFunc = 0;
                id->numArgs = 0;
                id->args = 0;
                id->argsIsArray = 0;

                sym_table_add(symbolTableStack.first->st, id);
            } 

            else { // not array
                idName = idGen(temp);
                id = sym_table_find(symbolTableStack.first->st, idName);
                if (id) {
                    printf("Redefinition of %s\n", idName);
                    return 1;
                }
                id->name = idName;
                id->type = typeGen(opr->op[0]);
                id->isArray = 0;
                id->isFunc = 0;
                id->numArgs = 0;
                id->args = 0;
                id->argsIsArray = 0;

                sym_table_add(symbolTableStack.first->st, id);

            }
            // assignment
            if (opr->op[1]->type == OPERATOR_NODE && opr->op[1]->opr.opType == assignment) {
                temp = opr->op[1]->opr.op[1];
                if (temp->type == ID_NODE) {
                    idName = idGen(temp);
                    id = sym_table_find(symbolTableStack.first->st, idName);
                    if (!id) {
                        printf("Identifier not found: %s\n", idName);
                        return 1;
                    }
                }
                else if (temp->type == OPERATOR_NODE) {
                    if (typeCheckingOpNode(&temp->opr))
                            return 1;
                }
            }
            break;

        case init_list:
            temp = opr->op[0];
            if (temp->type == ID_NODE) {
                idName = idGen(temp);
                id = sym_table_find(symbolTableStack.first->st, idName);
                if (!id) {
                    printf("Identifier not found: %s\n", idName);
                    return 1;
                }
            }

            else if (temp->type == OPERATOR_NODE && temp->opr.opType == concatenate) {
                idName = idGen(temp->opr.op[1]);
                id = sym_table_find(symbolTableStack.first->st, idName);
                if (!id) {
                    printf("Identifier not found: %s\n", idName);
                    return 1;
                }

                if (typeCheckingOpNode(&(temp->opr.op[0]->opr)))
                    return 1;
            }

            if (typeCheckingSubTree(opr->op[0])) return 1;
            break;

        case exp_state:
            temp = opr->op[0];
            if (temp->type == ID_NODE) {
                idName = idGen(temp->opr.op[1]);
                id = sym_table_find(symbolTableStack.first->st, idName);
                if (!id) {
                    printf("Identifier not found: %s\n", idName);
                    return 1;
                }
            }

            if (temp->type == OPERATOR_NODE) {
                if (typeCheckingOpNode(&temp->opr))
                    return 1;
            }

            break;

        case declar_state:
            if (typeCheckingSubTree(opr->op[0])) return 1;
            break;

        case comp_state:
            if (opr->numOperands == 1 && typeCheckingSubTree(opr->op[0])) return 1;
            break;

        case state_list:
            if (typeCheckingSubTree(opr->op[0])) return 1;
            if (typeCheckingSubTree(opr->op[1])) return 1;
            break;

        case select_state:
            temp = opr->op[0];
            if (temp->type == OPERATOR_NODE) {
                if (temp->opr.opType != math_op) {
                    printf ("Illegal index.\n");
                    return 1;
                }
                if (typeCheckingOpNode(&temp->opr)) return 1;

            }

            else if (temp->type == ID_NODE) {
                idName = idGen(temp);
                id = sym_table_find(symbolTableStack.first->st, idName);
                if (!id) {
                    printf ("Identifier not found: %s\n", idName);
                    return 1;
                }
                if (id->type != BOOL_TYPE && id->type != INT_TYPE) {
                    printf("Illegal if condition\n");
                    return 1;
                }
            }

            else if (temp->type != INTCON_NODE && temp->type != BOOLCON_NODE) {
                printf("Illegal if condition\n");
                return 1;
            }
            
            // generate new symbol table for the new scope
            newSymbolTable = (struct sym_table*) malloc(sizeof(struct sym_table));
            sym_table_init(newSymbolTable);
            st_list_add(&symbolTableStack, newSymbolTable);

            if (typeCheckingSubTree(opr->op[1])) return 1;

            // remove the top symbol table
            st_list_del(&symbolTableStack);

            if (opr->numOperands == 3) {
                // generate new symbol table for the new scope
                newSymbolTable = (struct sym_table*) malloc(sizeof(struct sym_table));
                sym_table_init(newSymbolTable);
                st_list_add(&symbolTableStack, newSymbolTable);

                if (typeCheckingSubTree(opr->op[2])) return 1;

                // remove the top symbol table
                st_list_del(&symbolTableStack);
            }
            break;

        case while_state:
            temp = opr->op[0];
            if (temp->type == OPERATOR_NODE) {
                if (temp->opr.opType != math_op) {
                    printf ("Illegal index.\n");
                    return 1;
                }
                if (typeCheckingOpNode(&temp->opr)) return 1;

            }

            else if (temp->type == ID_NODE) {
                idName = idGen(temp);
                id = sym_table_find(symbolTableStack.first->st, idName);
                if (!id) {
                    printf ("Identifier not found: %s\n", idName);
                    return 1;
                }
                if (id->type != BOOL_TYPE && id->type != INT_TYPE) {
                    printf("Illegal while condition\n");
                    return 1;
                }
            }

            else if (temp->type != INTCON_NODE && temp->type != BOOLCON_NODE) {
                printf("Illegal while condition\n");
                return 1;
            }

            // generate new symbol table for the new scope
            newSymbolTable = (struct sym_table*) malloc(sizeof(struct sym_table));
            sym_table_init(newSymbolTable);
            st_list_add(&symbolTableStack, newSymbolTable);

            if (typeCheckingSubTree(opr->op[1])) return 1;

            // remove the top symbol table 
            st_list_del(&symbolTableStack);
            
            break;

        case do_while_state:
            // generate new symbol table for the new scope
            newSymbolTable = (struct sym_table*) malloc(sizeof(struct sym_table));
            sym_table_init(newSymbolTable);
            st_list_add(&symbolTableStack, newSymbolTable);

            if (typeCheckingSubTree(opr->op[0])) return 1;

            // remove the top symbol table 
            st_list_del(&symbolTableStack);
            
            temp = opr->op[1];
            if (temp->type == OPERATOR_NODE) {
                if (temp->opr.opType != math_op) {
                    printf ("Illegal index.\n");
                    return 1;
                }
                if (typeCheckingOpNode(&temp->opr)) return 1;

            }

            else if (temp->type == ID_NODE) {
                idName = idGen(temp);
                id = sym_table_find(symbolTableStack.first->st, idName);
                if (!id) {
                    printf ("Identifier not found: %s\n", idName);
                    return 1;
                }
                if (id->type != BOOL_TYPE && id->type != INT_TYPE) {
                    printf("Illegal while condition\n");
                    return 1;
                }
            }

            else if (temp->type != INTCON_NODE && temp->type != BOOLCON_NODE) {
                printf("Illegal while condition\n");
                return 1;
            }

            break;

        case for_state:
            if (opr->op[0]->opr.opType == var_decl ||opr->op[0]->opr.opType == var_decl_disp || opr->op[0]->opr.opType == var_decl_hide) {
                // generate new symbol table for the new scope
                newSymbolTable = (struct sym_table*) malloc(sizeof(struct sym_table));
                sym_table_init(newSymbolTable);
                st_list_add(&symbolTableStack, newSymbolTable);

                if (typeCheckingSubTree(opr->op[0])) return 1;

                temp = opr->op[1];
                if (temp->type == OPERATOR_NODE) {
                    if (temp->opr.opType != math_op) {
                        printf ("Illegal index.\n");
                        return 1;
                    }
                    if (typeCheckingOpNode(&temp->opr)) return 1;

                }

                else if (temp->type == ID_NODE) {
                    idName = idGen(temp);
                    id = sym_table_find(symbolTableStack.first->st, idName);
                    if (!id) {
                        printf ("Identifier not found: %s\n", idName);
                        return 1;
                    }
                    if (id->type != BOOL_TYPE && id->type != INT_TYPE) {
                        printf("Illegal for condition\n");
                        return 1;
                    }
                }

                else if (temp->type != INTCON_NODE && temp->type != BOOLCON_NODE) {
                    printf("Illegal for condition\n");
                    return 1;
                }

                if (opr->numOperands == 4 && typeCheckingSubTree(opr->op[2])) return 1;
                if (typeCheckingSubTree(opr->op[opr->numOperands-1])) return 1;

                // remove the top symbol table
                st_list_del(&symbolTableStack);
            } 

            else {
                if (typeCheckingSubTree(opr->op[0])) return 1;

                temp = opr->op[1];
                if (temp->type == OPERATOR_NODE) {
                    if (temp->opr.opType != math_op) {
                        printf ("Illegal index.\n");
                        return 1;
                    }
                    if (typeCheckingOpNode(&temp->opr)) return 1;

                }

                else if (temp->type == ID_NODE) {
                    idName = idGen(temp);
                    id = sym_table_find(symbolTableStack.first->st, idName);
                    if (!id) {
                        printf ("Identifier not found: %s\n", idName);
                        return 1;
                    }
                    if (id->type != BOOL_TYPE && id->type != INT_TYPE) {
                        printf("Illegal for condition\n");
                        return 1;
                    }
                }

                else if (temp->type != INTCON_NODE && temp->type != BOOLCON_NODE) {
                    printf("Illegal for condition\n");
                    return 1;
                }

                if (opr->numOperands == 4 && typeCheckingSubTree(opr->op[2])) return 1;

                // generate new symbol table for the new scope
                newSymbolTable = (struct sym_table*) malloc(sizeof(struct sym_table));
                sym_table_init(newSymbolTable);
                st_list_add(&symbolTableStack, newSymbolTable);

                if (typeCheckingSubTree(opr->op[opr->numOperands-1])) return 1;

                // remove the top symbol table
                st_list_del(&symbolTableStack);
            }
            break;

        case jump_continue_state:
            break;

        case jump_break_state:
            st_list_del(&symbolTableStack);
            break;

        case jump_ret_state:
            if (opr->numOperands == 1 && typeCheckingSubTree(opr->op[0])) return 1;
            st_list_del(&symbolTableStack);
            break;

        case trans_unit:
            if (typeCheckingSubTree(opr->op[0])) return 1;
            if (typeCheckingSubTree(opr->op[1])) return 1;
            break;

        case func_def:
            // if there is not one symbol table in the stack, create one as the base
            if (!symbolTableStack.first) {
                // generate new symbol table for the new scope
                newSymbolTable = (struct sym_table*) malloc(sizeof(struct sym_table));
                sym_table_init(newSymbolTable);
                st_list_add(&symbolTableStack, newSymbolTable);
            }

            varTypeEnum returnType = typeGen(opr->op[0]); // function return type
            idName = idGen(opr->op[1]); // function name

            id = sym_table_find(symbolTableStack.last->st, idName);
            if (id) {
                printf("Function redefinition: %s\n", idName);
                return 1;
            }

            if (strcmp(opr->op[1]->id.value,"main") == 0)
                mainFun = 1;
            else
                mainFun = 0;

            // clear the parameter list
            clearParaList();
            paraCount = 0;

            // whether main function or not, a new scope is created.    
            // generate new symbol table for the new scope
            newSymbolTable = (struct sym_table*) malloc(sizeof(struct sym_table));
            sym_table_init(newSymbolTable);
            st_list_add(&symbolTableStack, newSymbolTable);

            if (mainFun) {
                if(returnType != VOID_TYPE && returnType != INT_TYPE) {
                    printf("Main function must return int or void.\n");
                    return 1;
                }

                if (opr->numOperands == 4) {
                    printf("Main function must not take any arguments.\n");
                    return 1;
                }

                id->name = idName; 
                id->type = returnType;
                id->isArray = 0;
                id->isFunc = 1;
                id->numArgs = 0;
                id->args = 0;
                id->argsIsArray = 0;

                sym_table_add(symbolTableStack.first->st, id);

            } 
            else if (opr->numOperands == 4) {
                getParaList(opr->op[2]);

                id->name = idName; 
                id->type = returnType;
                id->isArray = 0;
                id->isFunc = 0;
                id->numArgs = paraCount;
                id->args = (varTypeEnum*) malloc(sizeof(varTypeEnum));
                id->argsIsArray = (int*) malloc(sizeof(varTypeEnum));
                for (int paraIndex = 0; paraIndex < paraCount; paraIndex ++) {
                    id->args[i] = paraList[i]->type;
                    id->argsIsArray[i] = paraList[i]->isArray;
                }

                sym_table_add(symbolTableStack.first->st, id);
            }

            if (typeCheckingSubTree(opr->op[opr->numOperands-1])) return 1;

            // remove the top symbol table
            st_list_del(&symbolTableStack);
            break;

        default:
            break;
    }
    return 0;
}

void clearParaList() {
    int i = 0;
    if (!paraList) return;
    for (; i < paraCount; i ++) {
        struct identifier* tmp = paraList[i];
        if (!tmp) break;
        if (tmp->args) free(tmp->args);
        if(tmp->argsIsArray) free(tmp->argsIsArray);
        free(tmp);
    }
    free (paraList);
}

varTypeEnum typeGen(nodeType* node) {
    if (node->type != VARTYPE_NODE) 
        return -1;

    switch (node->varType.value) {
        case VOID_TYPE:
            return VOID_TYPE;
            break;
        case CHAR_TYPE:
            return CHAR_TYPE;
            break;
        case INT_TYPE:
            return INT_TYPE;
            break;
        case STRING_TYPE:
            return STRING_TYPE;
            break;
        case INDEX_TYPE:
            return INDEX_TYPE;
            break;
        case BOOL_TYPE:
            return BOOL_TYPE;
            break;
    }
}

char* idGen(nodeType* node) {
    if (node->type == ID_NODE)
        return node->id.value;
    else 
        printf ("Shining");
    return 0;
}

int getNumPara(oprNode* node) {
    if (node->opType == concatenate)
        return getNumPara(&node->op[0]->opr) + 1;
    return 1;
}

void getParaList(nodeType* node) {
    if (node->type != OPERATOR_NODE)
        return ;
    paraCount = getNumPara(&node->opr);

    nodeType* tmp = node;
    nodeType ** para_decl = (nodeType **) malloc (paraCount * sizeof (nodeType *)); 
    if (paraCount == 1) {
        para_decl[0] = node;
    }

    else {
        int i =0;
        while (tmp->opr.opType == concatenate) {
            para_decl[i] = tmp->opr.op[1];
            i ++;
            tmp = tmp->opr.op[0];
        }
    }

    clearParaList();
    paraList = (struct identifier**) malloc(paraCount * sizeof(struct identifier*));
    for (int i = 0; i < paraCount; i ++) {
        struct identifier *tmp = (struct identifier*) malloc(sizeof(struct identifier));

        nodeType* nodeTmp = para_decl[i];
        nodeType* temp1 = nodeTmp->opr.op[0];
        nodeType* temp2 = nodeTmp->opr.op[1];

        tmp->type = typeGen(temp1);
        if (temp2->type == ID_NODE) { // an identifier
            tmp->name = idGen(temp2);
            tmp->isArray = 0;
            tmp->isFunc = 0;
            tmp->numArgs = 0;
            tmp->args = 0;
            tmp->argsIsArray = 0;
        }

        else { // an array
            tmp->name = idGen(temp2->opr.op[0]);
            tmp->isArray = 1;
            tmp->isFunc = 0;
            tmp->numArgs = 0;
            tmp->args = 0;
            tmp->argsIsArray = 0;
        }

        free (nodeTmp);

        paraList[i] = tmp;
    }
    free (para_decl);
}




file: avl/tests/avl.test/.gitignore

constant
declaration_bool
declaration_bool_array
declaration_bool_array.avl~
declaration_char
declaration_index
declaration_int
declaration_string
display_bool
display_bool_array
display_char_array
display_int
display_int_array
display_string
expression_bool
expression_char
expression_char_array
expression_index
expression_int
expression_int_array
expression_string
insertion_sort
Makefile
Makefile.am
Makefile.in
operator_char_post
operator_char_unary
operator_int_post
operator_int_unary
operator_string_mid
statement_empty
statement_if



file: avl/tests/avl.test/cast.avl

int main(){

    int a = 48;
    char c = 'a';
    char b = (char) a;
    int d = (int) c;
    print b;
    print d;


}



file: avl/tests/avl.test/cast.sh

#!/bin/bash
avl -o cast cast.avl


file: avl/tests/avl.test/constant.avl

int main() {

    1;
    "hello world";
    "";
    'c';

    (1);
    ("hello world");
    ("");
    ('c');  
    
    print 1, "hello world", 's', "";
    return 0;
}



file: avl/tests/avl.test/constant.sh

#!/bin/bash
avl -o constant constant.avl


file: avl/tests/avl.test/declaration_bool.avl

int main(){

    bool b;
        bool b1 = true;
        display bool b2 = true;
        hide bool b3 = true;
        display bool b4;
        display bool b5;
    return 0;
}



file: avl/tests/avl.test/declaration_bool.sh

#!/bin/bash
avl -o declaration_bool declaration_bool.avl


file: avl/tests/avl.test/declaration_bool_array.avl

int main(){

    bool b6[5];
        display bool b7[5];
        hide bool b8[6];
        bool b9[3] = {true, true, false};

    return 0;
}



file: avl/tests/avl.test/declaration_bool_array.sh

#!/bin/bash
avl -o declaration_bool_array declaration_bool_array.avl


file: avl/tests/avl.test/declaration_char.avl

int main(){

    char c;
        char c1 = 'c';
        display char c2 = 'c';
        hide char c3 = 'c';
        display char c4;
        hide char c5;

    return 0;
}



file: avl/tests/avl.test/declaration_char.sh

#!/bin/bash
avl -o declaration_char declaration_char.avl


file: avl/tests/avl.test/declaration_char_array.avl

int main(){

    char c6[5];
        /*char c7[] = "hello world";*/
        display char c8[5];
        hide char c9[6];
        /*char c10[6] = "hello";*/
        char c12[5] = {'i','h','e','l','l'};

    return 0;
}



file: avl/tests/avl.test/declaration_char_array.sh

#!/bin/bash
avl -o declaration_char_array declaration_char_array.avl


file: avl/tests/avl.test/declaration_index.avl

int main(){

    index in1;
    index in2 = 1;
    display index in3 = 1;
    hide index in4 = 1;
    display index in5;
    hide index in6;

    return 0;
}



file: avl/tests/avl.test/declaration_index.sh

#!/bin/bash
avl -o declaration_index declaration_index.avl


file: avl/tests/avl.test/declaration_int.avl

int main(){


    int i;
        int i1 = 1;
        display int i2 = 1;
        hide int i3 = 1;
        display int i4;
        hide i5;

    return 0;
}



file: avl/tests/avl.test/declaration_int.sh

#!/bin/bash
avl -o declaration_int declaration_int.avl


file: avl/tests/avl.test/declaration_int_array.avl

int main(){

    int i6[5];
        display int i7[5];
        hide int i8[6];
        int i9[3] = {1,2,3};

    return 0;

}



file: avl/tests/avl.test/declaration_int_array.sh

#!/bin/bash
avl -o declaration_int_array declaration_int_array.avl


file: avl/tests/avl.test/declaration_string.avl

int main(){

    string s;
        string s1 = "hello world!";
        /*display string s2 = "hello world!";
        hide string s3 = "hello world!";
        display string s4;
        hide string s5;*/

    return 0;
}



file: avl/tests/avl.test/declaration_string.sh

#!/bin/bash
avl -o declaration_string declaration_string.avl


file: avl/tests/avl.test/display_bool.avl

int main(){

    display bool b  = true;
    <begin_display>
        b;
    <end_display>

    hide b;

    <begin_display>
        b;
    <end_display>

    return 0;
}



file: avl/tests/avl.test/display_bool.sh

#!/bin/bash
avl -o display_bool display_bool.avl


file: avl/tests/avl.test/display_bool_array.avl

int main(){

    display bool array[5] = {true,true,false,false,false};
    <begin_display>
        swap(array,1,2);
    <end_display>

    hide array;
    <begin_display>
        swap(array,1,2);
    <end_display>
    return 0;
}



file: avl/tests/avl.test/display_bool_array.sh

#!/bin/bash
avl -o display_bool_array display_bool_array.avl


file: avl/tests/avl.test/display_char.avl

int main(){

    display char c = 'd';
    <begin_display>
        c;
    <end_display>

    hide c; 
    <begin_display>
        c;
    <end_display>

    return 0;
}



file: avl/tests/avl.test/display_char.sh

#!/bin/bash
avl -o display_char display_char.avl



file: avl/tests/avl.test/display_char_array.avl

int main(){

    display char array[5] = {'1','2','3','4','5'};
    <begin_display>
        swap(array,1,2);
    <end_display>
    
    hide array;
    <begin_display>
        swap(array,1,2);
    <end_display>
    return 0;

}



file: avl/tests/avl.test/display_char_array.sh

#!/bin/bash
avl -o display_char_array display_char_array.avl


file: avl/tests/avl.test/display_index.avl

int main(){

    display int array[5] = {1,2,3,4,5};
    display index i = 1;
    display index j = 2;
    <begin_display>
        array[i];
        array[j];
    
        swap(array,i,j);
    <end_display>

    hide array;

    
    <begin_display>
        swap(array,i,j);
    <end_display>

    hide i;
    hide j;
    
    
    <begin_display>
        swap(array,i,j);
    <end_display>


    display array;
    <begin_display>
        swap(array,i,j);
    <end_display>
    

    return 0;
}



file: avl/tests/avl.test/display_index.sh

#!/bin/bash
avl -o display_index display_index.avl


file: avl/tests/avl.test/display_int.avl

int main(){

    display int i = 1;
    <begin_display>
        i;
    <end_display>

    hide i;
    <begin_display>
        i;
    <end_display>

    return 0;
}



file: avl/tests/avl.test/display_int.sh

#!/bin/bash
avl -o display_int display_int.avl


file: avl/tests/avl.test/display_int_array.avl

int main(){

    display int array[5] = {1,2,3,4,5};
    <begin_display>
        swap(array,1,2);
    <end_display>

    hide array;
    <begin_display>
        swap(array,1,2);
    <end_display>
    return 0;
}



file: avl/tests/avl.test/display_int_array.sh

#!/bin/bash
avl -o display_int_array display_int_array.avl


file: avl/tests/avl.test/display_string.avl

int main(){

    display string s = "hello world";
    <begin_display>
        s;
    <end_display>
    hide s;
    
    <begin_display>
        s;
    <end_display>
    
    return 0;
}



file: avl/tests/avl.test/display_string.sh

#!/bin/bash
avl -o display_string display_string.avl


file: avl/tests/avl.test/empty.avl




file: avl/tests/avl.test/empty.sh

#!/bin/bash
avl -t empty.avl



file: avl/tests/avl.test/expression_bool.avl

int main(){

    bool b = true;
    print b;
    b  = false;

    hide b;
    display b;

    print b;

}



file: avl/tests/avl.test/expression_bool.sh

#!/bin/bash
avl -o expression_bool expression_bool.avl


file: avl/tests/avl.test/expression_bool_array.avl

int main(){

    bool array[5] = {true, true, false, false, false};
    swap(array,1,2);
    hide array;
    display array;
    <begin_display>
        swap(array,1,2);
        array[4] = true;
    <end_display>
    return 0;
}



file: avl/tests/avl.test/expression_bool_array.sh

#!/bin/bash
avl -o expression_bool_array expression_bool_array.avl


file: avl/tests/avl.test/expression_char.avl

int main(){

    char c = 'c';
    print c;
    c = 'd';
    print c;

    hide c;
    display c;
    return 0;
}



file: avl/tests/avl.test/expression_char.sh

#!/bin/bash
avl -o expression_char expression_char.avl


file: avl/tests/avl.test/expression_char_array.avl

int main(){

    char array[5] = {'a','b','c','d','e'};
    swap(array,1,2);
    hide array;
    display array;
    <begin_display>
        swap(array,1,2);
        array[4] = 'f';
    <end_display>
    return 0;
}



file: avl/tests/avl.test/expression_char_array.sh

#!/bin/bash
avl -o expression_char_array expression_char_array.avl


file: avl/tests/avl.test/expression_index.avl

int main(){

    index i = 1;
    i = 2;
    
    hide i;
    display i;
    print i;
    return 0;

}



file: avl/tests/avl.test/expression_index.sh

#!/bin/bash
avl -o expression_index expression_index.avl


file: avl/tests/avl.test/expression_int.avl

int main(){

    int a = 1;
    print a;
    a = 2;
    print a;
    hide a;
    display a;

    return 0;
}



file: avl/tests/avl.test/expression_int.sh

#!/bin/bash
avl -o expression_int expression_int.avl


file: avl/tests/avl.test/expression_int_array.avl

int main(){

    int array[5] = {1, 2, 3, 4, 5};
    swap(array,1,2);
    hide array;
    display array;
    <begin_display>
        swap(array,1,2);
        array[4] = 6;
    <end_display>
    return 0;
}



file: avl/tests/avl.test/expression_int_array.sh

#!/bin/bash
avl -o expression_int_array expression_int_array.avl


file: avl/tests/avl.test/expression_string.avl

int main(){

    string s = "123";
    print s;
    s = "abc";  
    print s;
    hide s;
    display s;

    return 0;
}



file: avl/tests/avl.test/expression_string.sh

#!/bin/bash
avl -o expression_string expression_string.avl


file: avl/tests/avl.test/function_bool.avl

bool test(bool x){
    x = !x;
    return x;

}

int main(){

    bool b = true;
    print test(b);
    print b;
    return 0;

}




file: avl/tests/avl.test/function_bool.sh

#!/bin/bash
avl -o function_bool function_bool.avl


file: avl/tests/avl.test/function_bool_array.avl

void test(bool x[]){

    index l = len(x);
    if( l <= 1)
        print x[0];
    else{
        print x[l-1];
        test(x[0:l-1]);
    }

    return;

}

int main(){

    bool array[] = {true,true,false,false,false};
    <begin_display>

        test(array);

    <end_display>
    return 0;
}



file: avl/tests/avl.test/function_bool_array.sh

#!/bin/bash
avl -o function_bool_array function_bool_array.avl


file: avl/tests/avl.test/function_char.avl


char test(char x){

    x++;
    return x;

}

int main(){

    char c = 'd';
    print test(c);
    return 0;

}




file: avl/tests/avl.test/function_char.sh

#!/bin/bash
avl -o function_char function_char.avl


file: avl/tests/avl.test/function_char_array.avl


void test(char x[]){

    index l = len(x);
    if( l <= 1)
        print x[0];
    else{
        print x[l-1];
        return test(x[0:l-1]);
    }

    return;

}

int main(){

    char array[] = {'1','2','3','4','5'};
    <begin_display>

        test(array);

    <end_display>
    return 0;
}





file: avl/tests/avl.test/function_char_array.sh

#!/bin/bash
avl -o function_char_array function_char_array.avl


file: avl/tests/avl.test/function_empty.avl


void empty(){

}

int main(){

    empty();

}




file: avl/tests/avl.test/function_empty.sh

#!/bin/bash
avl -o function_empty function_empty.avl


file: avl/tests/avl.test/function_index.avl


index test(index x){

    x++;
    return x;

}

int main(){

    index i = 1;
    test(i);
    return 0;

}




file: avl/tests/avl.test/function_index.sh

#!/bin/bash
avl -o function_index function_index.avl


file: avl/tests/avl.test/function_int.avl


int test(int x){
    x++;
    return x;
}


int main(){

    int a = 1;
    print test(a);
    print a;
    return 0;
}




file: avl/tests/avl.test/function_int.sh

#!/bin/bash
avl -o function_int function_int.avl


file: avl/tests/avl.test/function_int_array.avl

void test(int x[]){
    index l = len(x);
    if( l <= 1 )
        print x[0];
    else{
        print x[l-1];
        test(x[0:l-1]);
    }

    return;

}

int main(){

    int array[] = {1,2,3,4,5};
    <begin_display>
        test(array);
    <end_display>
    return 0;

}



file: avl/tests/avl.test/function_int_array.sh

#!/bin/bash
avl -o function_int_array function_int_array.avl


file: avl/tests/avl.test/function_string.avl

string test(string x){
    
    x = "hello anthoer world";
    return x;
}

int main(){

    string s= "hello world";
    print test(s),s;
    return 0;

}




file: avl/tests/avl.test/function_string.sh

#!/bin/bash
avl -o function_string function_string.avl


file: avl/tests/avl.test/hello_world.avl

int main() {
    <begin_display>
    <begin_display>
    display char str[] = "Hello world!";
    display int a[] = {1, 2, 3, 4};
    <end_display>
    <end_display>
    return 0;
}




file: avl/tests/avl.test/hello_world.sh

#!/bin/bash
avl -o hello_world hello_world.avl


file: avl/tests/avl.test/init_test.sh

#!/bin/bash



file: avl/tests/avl.test/insertion_sort.avl

int main() {
    display int a[] = {5, 2, 7, 3, 6, 8};
    <begin_display>
    for (display index i = 1; i < len(a); i = i + 1) {
        display index j = i - 1;
        while (j >= 0 && a[j] > a[j + 1]) {
            swap(a, j + 1, j);
            j = j - 1;
        }
    }
    <end_display>
    return 0;
}





file: avl/tests/avl.test/insertion_sort.sh

#!/bin/bash
avl -o insertion_sort insertion_sort.avl


file: avl/tests/avl.test/kmp.avl

index[] get_overlap(char pattern[]) {
    <begin_display>
    display index result[len(pattern)];
    display index k = 0;
    for (index i = 1; i < len(pattern); i = i + 1) {
        while (k > 0 && pattern[k] != pattern[i])
            k = result[k - 1];
        if (pattern[k] == pattern[i]) {
            k = k + 1;
            result[i] = k;
        }
    }
    <end_display>
    return result;
}

index kmp(char target[], char pattern[], index overlap[]) {
    <begin_display>
    display index q = 0;
    for (index i = 0; i < len(target); i = i + 1) {
    while (q > 0 && pattern[q] != target[i])
        q = overlap[q - 1];
        if (pattern[q] == target[i])
            q = q + 1;
        if (q == len(pattern))
            return i - m + 1;
    }
    <end_display>
    return -1;
}

int main() {
    <begin_display>
    display char target[] = banananobano;
    display char pattern[] = nano;
    display int overlap[] = get_overlap(pattern);
    index result = kmp(target, pattern, overlap);
    <end_display>
    print(result);
}



file: avl/tests/avl.test/kmp.sh

#!/bin/bash
avl -o kmp kmp.avl


file: avl/tests/avl.test/Makefile.am

AM_TESTS_ENVIRONMENT = . $(srcdir)/init_test.sh;
AM_TESTS_FD_REDIRECT = 9>&2

TESTS = \
            cast.sh \
            constant.sh \
            declaration_bool.sh \
            declaration_bool_array.sh \
            declaration_char.sh \
            declaration_char_array.sh \
            declaration_index.sh \
            declaration_int.sh \
            declaration_int_array.sh \
            declaration_string.sh \
            display_bool.sh \
            display_bool_array.sh \
            display_char.sh \
            display_char_array.sh \
            display_index.sh \
            display_int.sh \
            display_int_array.sh \
            display_string.sh \
            empty.sh \
            expression_bool.sh \
            expression_bool_array.sh \
            expression_char.sh \
            expression_char_array.sh \
            expression_index.sh \
            expression_int.sh \
            expression_int_array.sh \
            expression_string.sh \
            function_bool.sh \
            function_bool_array.sh \
            function_char.sh \
            function_char_array.sh \
            function_empty.sh \
            function_index.sh \
            function_int.sh \
            function_int_array.sh \
            function_string.sh \
            hello_world.sh \
            init_test.sh \
            insertion_sort.sh \
            kmp.sh \
            operator_bool_mid.sh \
            operator_bool_post.sh \
            operator_char_mid.sh \
            operator_char_post.sh \
            operator_char_unary.sh \
            operator_index_mid.sh \
            operator_index_post.sh \
            operator_index_unary.sh \
            operator_int_mid.sh \
            operator_int_post.sh \
            operator_int_unary.sh \
            operator_string_mid.sh \
            quick_sort.sh \
            statement_empty.sh \
            statement_for.sh \
            statement_if.sh \
            statement_while.sh \
            statement_scope.sh \
            subarray_int.sh \
            mergeSort.sh \
            maxSubarray.sh

XFAIL_TESTS = \
            cast.sh \
            statement_scope.sh \
            empty.sh



file: avl/tests/avl.test/maxSubarray.avl

void findMaxCrossSubarray(int A[], int mid, int cross[]) {
    int leftsum = 0;
    bool init = false;
    int sum = 0;
    int max_left = 0;

    int count = mid - cross[0];
    <begin_display>
    for (index i = mid - cross[0]; i >=0; i--) {
        sum = sum + A[i];
        if (!init || sum > leftsum) {
            leftsum = sum;
            max_left = count + cross[0];
            init = true;
        }
        count--;
    }
    <end_display>

    int rightsum = 0;
    init = false;
    sum = 0;
    int  max_right = 0;

    count = mid + 1 - cross[0];
    <begin_display>
    for (index j = mid + 1 - cross[0]; j < len(A); j++) {
        sum = sum + A[j];
        if (!init || sum > rightsum) {
            rightsum = sum;
            max_right = count + cross[0];
            init = true;
        }
        count++;
    }
    <end_display>

    cross[0] = max_left;
    cross[1] = max_right;
    cross[2] = leftsum + rightsum;
}

void findMaxSubarray(int A[], int ret[]) {
    if (ret[0] >= ret[1]) {
        ret[2] = A[0];
        return;
    }

    <begin_display>
    display index low = 0;
    display index high = len(A) - 1;
    display index mid = (low + high) / 2;

    int m = (ret[0] + ret[1]) / 2;

    int left[] = {0,0,0};
    left[0] = ret[0];
    left[1] = m;

    int right[] = {0,0,0};
    right[0] = m + 1;
    right[1] = ret[1];

    int cross[] = {0,0,0};
    cross[0] = ret[0];
    cross[1] = ret[1];

    findMaxSubarray(A[low : (mid + 1)], left);
    findMaxSubarray(A[(mid + 1) :  (high + 1)], right);
    findMaxCrossSubarray(A, m, cross);
    
    if (left[2] >= right[2] && left[2] >= cross[2]) {
        ret[0] = left[0];
        ret[1] = left[1];
        ret[2] = left[2];
    }
    else if (right[2] >= left[2] && right[2] >= cross[2]) {
        ret[0] = right[0];
        ret[1] = right[1];
        ret[2] = right[2];
    }
    else {
        ret[0] = cross[0];
        ret[1] = cross[1];
        ret[2] = cross[2];
    }
    <end_display>
}


int main() {
    display int A[] = {1,3,4,-8,-3,2,-1,0,4};
    int ret[] = {0,0,0};
    ret[1] = len(A) - 1;

    <begin_display>
    findMaxSubarray(A, ret);
    <end_display>
    
    index s = ret[0];
    index e = ret[1];

    <begin_display>
    display int B[] = A[s:(e+1)];
    <end_display>
    
    return 0;
}



file: avl/tests/avl.test/maxSubarray.sh

#!/bin/bash
avl -o maxSubarray maxSubarray.avl



file: avl/tests/avl.test/mergeSort.avl

void mergeSort(int A[]) {
    if (len(A) <= 1)
        return;
    
    display index s = 0;
    display index e = len(A) - 1;
    display index m = (s + e) / 2;
    
    <begin_display>
    mergeSort(A[s:(m+1)]);
    mergeSort(A[(m+1):(e+1)]);
    <end_display>

    int tmp[] = A[s:(m+1)];
    display int L[len(tmp)];
    for (index i = 0; i < len(tmp); i++) {
        L[i] = tmp[i];
    }

    tmp = A[(m+1):(e+1)];
    display int R[len(tmp)];
    for (index i = 0; i < len(tmp); i++) {
        R[i] = tmp[i];
    }
    
    display index l = 0;
    display index r = 0;

    <begin_display>
    for (index i = s; i <= e; i++) {
        if (l == m - s + 1) {
            while (r < e - m) {
                A[i] = R[r];
                ++i;
                ++r;
            }
            break;
        }

        if (r == e - m) {
            while (l < m - s + 1) {
                A[i] = L[l];
                ++i;
                ++l;
            }
            break;
        }

        if (L[l] <= R[r]) {
            A[i] = L[l];
            ++l;
        } else {
            A[i] = R[r];
            ++r;
        }
    }
    <end_display>
}



int main() {
    <begin_display>
    display int A[] = {2, 4, 1, 10, 8, 7, 5, 5, 3, 3};
    mergeSort(A);
    <end_display>
    return 0;
}



file: avl/tests/avl.test/mergeSort.sh

#!/bin/bash
avl -o mergeSort mergeSort.avl



file: avl/tests/avl.test/operator_bool_mid.avl

int main(){

    bool a = true;
    bool b = false;
    print a && b;
    print a || b;
    return 0;
}



file: avl/tests/avl.test/operator_bool_mid.sh

#!/bin/bash
avl -o operator_bool_mid operator_bool_mid.avl


file: avl/tests/avl.test/operator_bool_post.avl

int main(){

    bool a = true;
    print (!a); 

}



file: avl/tests/avl.test/operator_bool_post.sh

#!/bin/bash
avl -o operator_bool_post operator_bool_post.avl


file: avl/tests/avl.test/operator_char_mid.avl

int main(){

    char c = 'c';
    int b = 2;
    int a  = 'b'; 
    print c*b, c/b;
    print c+b,4-b;
    print c>a, c<a, c>=a, c<=a;
    print c!=a, c==a;
    print c == 'c', c != 'c';
    
    return 0;
}



file: avl/tests/avl.test/operator_char_mid.sh

#!/bin/bash
avl -o operator_char_mid operator_char_mid.avl


file: avl/tests/avl.test/operator_char_post.avl

int main(){

    char a = 'c';
    
    print a++;
    print a;
    print a--;
    print a;

}



file: avl/tests/avl.test/operator_char_post.sh

#!/bin/bash
avl -o operator_char_post operator_char_post.avl


file: avl/tests/avl.test/operator_char_unary.avl

int main(){
    
    char a = 'c';
    print ++a;
    print a;
    print --a;
    print a;        

    return 0;
}



file: avl/tests/avl.test/operator_char_unary.sh

#!/bin/bash
avl -o operator_char_unary operator_char_unary.avl


file: avl/tests/avl.test/operator_index_mid.avl

int main(){


    index i = 1;
    index j = 2;
    int a = 1;

    print i*j,i/j;
    print i*a,i/a;
    print i+j, i-j;
    print i+a, i-a;
    print i>j, i<j, i>=j, i<=j;
    print j>i, j<i, j>=i, j<=i;
    
    index n = 1;
    print i>n, i<n, i>=n, i<=n;
    print i>a, i<a, i>=a, i<=a;
    print i!=j,i==j;
    print i!=n,i==n;
    print i!=a,i==a;
    

    return 0;
}





file: avl/tests/avl.test/operator_index_mid.sh

#!/bin/bash
avl -o operator_index_mid operator_index_mid.avl


file: avl/tests/avl.test/operator_index_post.avl

int main(){

    index i = 1;
    print i++;
    print i;
    print i--;
    print i;
    return 0;
}



file: avl/tests/avl.test/operator_index_post.sh

#!/bin/bash
avl -o operator_index_post operator_index_post.avl


file: avl/tests/avl.test/operator_index_unary.avl

int main(){

    index i = 0;
    print --i;
    print i;
    print ++i;
    print i;
    print +i;
    print -i;   

    return 0;

}



file: avl/tests/avl.test/operator_index_unary.sh

#!/bin/bash
avl -o operator_index_unary operator_index_unary.avl


file: avl/tests/avl.test/operator_int_mid.avl

int main(){

    int a = 3;
    int b = 2;
    int c = 3;
    int d = 4;
    int e = c%d;
    print a*b, a/b, a%b;
    print a+b, a-b;
    print a>b, a<b, a>=b, a<=b;
    print a!=b, a==b;
    print a>c, a<c, a>=c, a<=c;
    print a!=c, a==c;
    print a>d, a<d, a>=d, a<=d;
    print a!=d, a==d;   
    return 0;
}



file: avl/tests/avl.test/operator_int_mid.sh

#!/bin/bash
avl -o operator_int_mid operator_int_mid.avl


file: avl/tests/avl.test/operator_int_post.avl

int main(){

    int a = 1;
    print +a;
    print -a;
    print ++a;
    print a;
    print --a;
    print a;
    return 0;
}



file: avl/tests/avl.test/operator_int_post.sh

#!/bin/bash
avl -o operator_int_post operator_int_post.avl


file: avl/tests/avl.test/operator_int_unary.avl

int main(){

    int a = 1;
    print a++;
    print a;
    print a--;
    print a;

    return 0;

}



file: avl/tests/avl.test/operator_int_unary.sh

#!/bin/bash
avl -o operator_int_unary operator_int_unary.avl


file: avl/tests/avl.test/operator_string_mid.avl

int main(){

    string a = "hello ";
    print a;
    string b = "world";
    print b;
    string c = a + b;
    print c;

    return 0;
}



file: avl/tests/avl.test/operator_string_mid.sh

#!/bin/bash
avl -o operator_string_mid operator_string_mid.avl


file: avl/tests/avl.test/quick_sort.avl

void quicksort(int a[]) {
    if (len(a) <= 1)
        return;
    display index i = -1;
    display index j = 0;
    display index k = len(a) - 1;
    display index e = k;
    <begin_display>
    while (j < k) {
        if (a[j] >= a[e]) {
            j = j + 1;
        }
        else {
            swap(a, i + 1, j);
            i = i + 1;
            j = j + 1;
        }

    }
    swap(a, i + 1, e);
    quicksort(a[0 : (i+1)]);
    quicksort(a[(i + 2) : (k + 1)]);
    <end_display>
}

int main() {
    <begin_display>
    display int a[] = {5, 2, 3, 6, 1, 7, 4, 9, 8};
    quicksort(a);
    <end_display>
    return 0;
}



file: avl/tests/avl.test/quick_sort.sh

#!/bin/bash
avl -o quick_sort quick_sort.avl


file: avl/tests/avl.test/statement_empty.avl

int main(){


    int a = 1;
    {

    }
    
    return 0;
}



file: avl/tests/avl.test/statement_empty.sh

#!/bin/bash
avl -o statement_empty statement_empty.avl


file: avl/tests/avl.test/statement_for.avl

int main(){

    /*empty, line 4 failed*/
    for(int i = 0; i<10; i++);

    for(int i = 0; i<10; i++){

    }

    /*regular for*/
    for(int i = 0; i<10; i++){
        print i;
    }
    
    /*changing i inside*/
    for(int i = 0; i<10;){
        print i;
        i = i+2;
    }

    /*decleare i outside for*/
    int i = 0;
    for(i;i<10;i++)
        print i;
    for(i;i>0;)
        print i--;

    /*testing continue,break*/
    for(i;i<10;i++){
        if(i == 2)
            continue;
        else if( i == 5)
            break;
        print i;
    }


    /*testing nested for*/
    for(i=0;i<3;i++){
        for(int j = 0; j<2; j++)
            print j;
    }

    /*testing return*/
    for(i=0;i<10;i++){
        print i;
        if(i==5)
            return 0;
    }


    return 0;
}



file: avl/tests/avl.test/statement_for.sh

#!/bin/bash
avl -o statement_for statement_for.avl


file: avl/tests/avl.test/statement_if.avl

int main(){

    int a = 1;
    int b = 3;
    if(a < b){
        if(a<b)
            print a;
        if(a>b)
            print b;
    }else{
        print "I should be displayed";

    }

    if(a > b){
        print "I should be displayed";
    }else{
        print "correct!";
    }

    return 0;
}



file: avl/tests/avl.test/statement_if.sh

#!/bin/bash
avl -o statement_if statement_if.avl


file: avl/tests/avl.test/statement_scope.avl

int main(){

    int a = 1;
    {
        int j = 1;
    }
    print j;
    return 0;

}



file: avl/tests/avl.test/statement_scope.sh

#!/bin/bash
avl -t statement_scope.avl



file: avl/tests/avl.test/statement_while.avl

int main(){

    int i = 0;

    /*empty while, failed*/
    while(i++ < 10);
    while(i-- > 0){}

    /*empty do while, failed*/
    do;
    while(i++<10);

    /*normal while*/
    while(i>0){
        print i;
        i--;
    }

    while(i<10)
        print i++;
    
    /*normal do while*/
    do print i--;
    while ( i > 0);

    do{
        print i;
        i++;
    }while ( i < 10 );

    /*break , continue and return*/

    while(i > 0){
        i--;
        if(i == 2)
            continue;
        else if(i==5)
            break;
        print i;
        

    }

    i = 0;
    while(i++<3){
        int j = 0;
        while(j<2)
            print j++;
    }
    i=0;

    
    while(i < 10){
        print i++;
        if(i == 5)
            return 0;
    }

    
    
    return 0;
}



file: avl/tests/avl.test/statement_while.sh

#!/bin/bash
avl -o statement_while statement_while.avl


file: avl/tests/avl.test/subarray_int.avl

void subarray(int x[]){
    index l = len(x);
    if(l<=1)
        return;

    <begin_display>
        subarray(x[0:l]);
    <end_display>   

    

}

int main(){

    display int array[10];
    int j = 0;
    for(index i = 0; i < 10; i++) {
        array[i] = j;
        j++;
    }
    <begin_display>
        subarray(array);
    <end_display>

    return 0;

}






file: avl/tests/avl.test/subarray_int.sh

#!/bin/bash
avl -o subarray_int subarray_int.avl


file: avl/tests/error.test/array_malvalue.avl

int main() {
    bool a = true;
    int test[10];
    test[1] = a;

    return 0l
}



file: avl/tests/error.test/array_malvalue.sh

#!/bin/bash
avl -t array_malvalue.avl



file: avl/tests/error.test/array_nosize.avl

int main() {
    bool a[];
    return 0;
}



file: avl/tests/error.test/array_nosize.sh

#!/bin/bash
avl -t array_nosize.avl



file: avl/tests/error.test/break.avl

int main() {
    int i = 0;
    while(i < 10) {
        print i;
    }
    break;

    return 0;
}



file: avl/tests/error.test/break.sh

#!/bin/bash
avl -t break.avl



file: avl/tests/error.test/display_unmatch.avl

int main() {
    <begin_display>
    int a = 6;
    print a;
    <end_display>
    <end_display>
    return 0;
}



file: avl/tests/error.test/display_unmatch.sh

#!/bin/bash
avl -t display_unmatch.avl 



file: avl/tests/error.test/dup_break.avl

int main() {
    for (int i = 0; i < 10; i++) {
        break;
        break;
    }
    return 0;
}



file: avl/tests/error.test/dup_break.sh

#!/bin/bash
avl -t dup_break.avl



file: avl/tests/error.test/func_malformat.avl

int test() {
    return 1;
}

int main(){
    test + 1;
    return 0;
}



file: avl/tests/error.test/func_malformat.sh

#!/bin/bash
avl -t func_malformat.avl



file: avl/tests/error.test/func_malparam.avl

int test(int b) {
    return b + 1;
}

int main() {
    test(true);
    return 0;
}



file: avl/tests/error.test/func_malparam.sh

#!/bin/bash
avl -t func_malparam.avl



file: avl/tests/error.test/func_malscope.avl

void test_b() {

    int test_a(int a) {
        return a+1;
    }

    int a = 1;
    int b = test_a(a);

    print b;
}

int main() {

    test_a();

    return 0;
}



file: avl/tests/error.test/func_malscope.sh

#!/bin/bash
avl -t func_malscope.avl



file: avl/tests/error.test/func_malvalue.avl

int test(bool b) {
    return b;
}

int main() {
    test(true);
    return 0;
}



file: avl/tests/error.test/func_malvalue.sh

#!/bin/bash
avl -t func_malvalue.avl



file: avl/tests/error.test/func_missvalue.avl

int test(int a) {
    int b = a + 1;
}

int main() {
    test(1);
    return 0;
}



file: avl/tests/error.test/func_missvalue.sh

#!/bin/bash
avl -t func_missvalue.avl



file: avl/tests/error.test/func_numparam.avl

int test(int a, int b) {
    return a + b;
}

int main() {
    int a = 1;
    int b = 2;
    int c = test(a,b,3,4,5);
    return 0;
}



file: avl/tests/error.test/func_numparam.sh

#!/bin/bash
avl -t func_numparam.avl



file: avl/tests/error.test/func_undefine.avl

int main(){
    int a = test();
    print a;
    return 0;
}

int test() {
    return 1;
}



file: avl/tests/error.test/func_undefine.sh

#!/bin/bash
avl -t func_undefine.avl



file: avl/tests/error.test/init_test.sh

#!/bin/bash



file: avl/tests/error.test/Makefile.am

AM_TESTS_ENVIRONMENT = . $(srcdir)/init_test.sh;
AM_TESTS_FD_REDIRECT = 9>&2

TESTS = \
            func_malformat.sh \
            func_malparam.sh \
            func_malscope.sh \
            func_malvalue.sh \
            func_missvalue.sh \
            func_undefine.sh \
            func_numparam.sh \
            break.sh \
            dup_break.sh \
            display_unmatch.sh \
            array_nosize.sh \
            array_malvalue.sh

XFAIL_TESTS = \
            func_malformat.sh \
            func_malparam.sh \
            func_malscope.sh \
            func_malvalue.sh \
            func_missvalue.sh \
            func_undefine.sh \
            func_numparam.sh \
            break.sh \
            dup_break.sh \
            display_unmatch.sh \
            array_nosize.sh \
            array_malvalue.sh





file: avl/tests/libavl.test/.gitignore

avlint_assign1
avlint_add1
avlint_add2
avlint_add3
avlint_sub1



file: avl/tests/libavl.test/avlint_add1.cpp

#include <iostream>
#include <cstdlib>
#include "AvlTypes.h"
using namespace std;

int main(int argc, char *argv[])
{
    AvlInt a = atoi(argv[1]);
    int b = atoi(argv[2]);

    cout << a + b << endl;

    return 0;
}



file: avl/tests/libavl.test/avlint_add1.sh

#!/bin/bash

SUCCESS=0

program="./avlint_add1"
declare -i n=20
declare -a input=("0 0" "1 2" "-1 -2" "-1 2" "-2 1")

source genRandom.sh
genRandom $n 2
input=("${input[@]}" "${rArray[@]}")
len=${#input[@]}

for i in $(seq 1 $(( len - 1 )))
do
    num1=`echo ${input[$i]} | awk '{print $1}'`
    num2=`echo ${input[$i]} | awk '{print $2}'`
    expected=$(( num1 + num2 ))
    output=`$program ${input[$i]}`

    if [[ "$output" != "$expected" ]]
    then
        SUCCESS=1
    fi
done

exit $SUCCESS



file: avl/tests/libavl.test/avlint_add2.cpp

#include <iostream>
#include <cstdlib>
#include "AvlTypes.h"
using namespace std;

int main(int argc, char *argv[])
{
    AvlInt a = atoi(argv[1]);
    AvlInt b = atoi(argv[2]);

    cout << a + b << endl;

    return 0;
}



file: avl/tests/libavl.test/avlint_add2.sh

#!/bin/bash

SUCCESS=0

program="./avlint_add2"
declare -i n=20
declare -a input=("0 0" "1 2" "-1 -2" "-1 2" "-2 1")

source genRandom.sh
genRandom $n 2
input=("${input[@]}" "${rArray[@]}")
len=${#input[@]}

for i in $(seq 1 $(( len - 1 )))
do
    num1=`echo ${input[$i]} | awk '{print $1}'`
    num2=`echo ${input[$i]} | awk '{print $2}'`
    expected=$(( num1 + num2 ))
    output=`$program ${input[$i]}`

    if [[ "$output" != "$expected" ]]
    then
        SUCCESS=1
    fi
done

exit $SUCCESS



file: avl/tests/libavl.test/avlint_add3.cpp

#include <iostream>
#include <cstdlib>
#include "AvlTypes.h"
using namespace std;

int main(int argc, char *argv[])
{
    int a = atoi(argv[1]);
    AvlInt b = atoi(argv[2]);

    cout << a + b << endl;

    return 0;
}



file: avl/tests/libavl.test/avlint_add3.sh

#!/bin/bash

SUCCESS=0

program="./avlint_add3"
declare -i n=20
declare -a input=("0 0" "1 2" "-1 -2" "-1 2" "-2 1")

source genRandom.sh
genRandom $n 2
input=("${input[@]}" "${rArray[@]}")
len=${#input[@]}

for i in $(seq 1 $(( len - 1 )))
do
    num1=`echo ${input[$i]} | awk '{print $1}'`
    num2=`echo ${input[$i]} | awk '{print $2}'`
    expected=$(( num1 + num2 ))
    output=`$program ${input[$i]}`

    if [[ "$output" != "$expected" ]]
    then
        SUCCESS=1
    fi
done

exit $SUCCESS



file: avl/tests/libavl.test/avlint_assign1.cpp

#include <iostream>
#include <cstdlib>
#include "AvlTypes.h"
using namespace std;

int main(int argc, char *argv[])
{
    int num = atoi(argv[1]);

    AvlInt a = num;

    cout << a << endl;

    return 0;
}



file: avl/tests/libavl.test/avlint_assign1.sh

#!/bin/bash

SUCCESS=0

program="./avlint_assign1"
declare -i n=20
declare -a input=("0")

source genRandom.sh
genRandom $n 1
input=("${input[@]}" "${rArray[@]}")
len=${#input[@]}

for i in $(seq 1 $(( len - 1 )))
do
    num=`echo ${input[$i]} | awk '{print $1}'`
    expected=$(( num ))
    output=`$program ${input[$i]}`

    if [[ "$output" != "$expected" ]]
    then
        SUCCESS=1
    fi
done

exit $SUCCESS



file: avl/tests/libavl.test/avlint_sub1.cpp

#include <iostream>
#include <cstdlib>
#include "AvlTypes.h"
using namespace std;

int main(int argc, char *argv[])
{
    AvlInt a = atoi(argv[1]);
    int b = atoi(argv[2]);

    cout << a - b << endl;

    return 0;
}



file: avl/tests/libavl.test/avlint_sub1.sh

#!/bin/bash

SUCCESS=0

program="./avlint_sub1"
declare -i n=20
declare -a input=( "0 0" "3 1" "1 3" "-1 -2" "-2 -1" "-1 2" "-2 1" "1 -2")

source genRandom.sh
genRandom $n 2
input=("${input[@]}" "${rArray[@]}")
len=${#input[@]}

for i in $(seq 1 $(( len - 1 )))
do
    num1=`echo ${input[$i]} | awk '{print $1}'`
    num2=`echo ${input[$i]} | awk '{print $2}'`
    expected=$(( num1 - num2 ))
    output=`$program ${input[$i]}`

    if [[ "$output" != "$expected" ]]
    then
        SUCCESS=1
    fi
done


exit $SUCCESS



file: avl/tests/libavl.test/genRandom.sh

#!/bin/bash

declare -a rArray=()

# Argument 1: #elements in the array
# Argument 2: #numbers in each element
genRandom ()
{
    rArray=()
    declare -i n=$(( $1 - 1 ))

    for i in $(seq 0 $n)
    do
        element=$(( ( RANDOM % 20000 ) - 10000 ))

        if [[ $2 -ge 2 ]]
        then
            for j in $(seq 2 $2)
            do
                num=$(( ( RANDOM % 20000 ) - 10000 ))
                element="$element $num"
            done
        fi

        rArray[$i]="$element"
    done
}



file: avl/tests/libavl.test/init_test.sh

#!/bin/bash



file: avl/tests/libavl.test/Makefile.am

check_PROGRAMS = \
                 avlint_assign1 \
                 avlint_add1 \
                 avlint_add2 \
                 avlint_add3 \
                 avlint_sub1

avlint_assign1_SOURCES = avlint_assign1.cpp
avlint_add1_SOURCES = avlint_add1.cpp
avlint_add2_SOURCES = avlint_add2.cpp
avlint_add3_SOURCES = avlint_add3.cpp
avlint_sub1_SOURCES = avlint_sub1.cpp

AM_CPPFLAGS = -Wall -Werror -std=c++11 -I$(top_builddir)/lib -I/opt/local/include
AM_LDFLAGS = -L$(top_builddir)/lib -L/opt/local/lib -lavl -lglut -lGL

AM_TESTS_ENVIRONMENT = . $(srcdir)/init_test.sh;
AM_TESTS_FD_REDIRECT = 9>&2

TESTS = \
        avlint_assign1.sh \
        avlint_add1.sh \
        avlint_add2.sh \
        avlint_add3.sh \
        avlint_sub1.sh



file: avl/tests/Makefile.am

SUBDIRS = libavl.test avl.test error.test



\end{verbatim}
